diff --git a/node_modules/dero-xswd-api/README.md b/node_modules/dero-xswd-api/README.md
index c73a7c0..9e69ceb 100644
--- a/node_modules/dero-xswd-api/README.md
+++ b/node_modules/dero-xswd-api/README.md
@@ -24,7 +24,7 @@ const name = "My application";
 
 // Fill up some info, these fields must be non-empty
 const appInfo: AppInfo = {
-  id: await generateAppId(name), // generates a hash automatically
+  id: generateAppId(name), // generates a hash automatically
   name,
   description: "My app's description",
   url: "https://myapp.com" // Optional
@@ -34,24 +34,63 @@ const appInfo: AppInfo = {
 const xswd = new Api(appInfo);
 
 // Initialize the connection => Will require to confirm in your wallet
-await xswd.initialize();
+await xswd.initializeXSWD();
 ```
 ##### Javascript
 ```js
-/* Javascript */
 import { Api, generateAppId } from "dero-xswd-api";
 
 const name = "My application";
 
 const appInfo = {
-  id: await generateAppId(name),
+  id: generateAppId(name),
   name,
   description: "My app's description",
+  url: "https://myapp.com" // Optional
 };
 
 const xswd = new Api(appInfo);
 
-await xswd.initialize();
+await xswd.initializeXSWD();
+```
+
+#### Using custom configuration and fallback node connection
+
+```ts
+// Refer to Config type in "src/types/types.ts"
+const config /*: Config */= {
+  address: "127.0.0.1",
+  port: 40000, // example for simulator wallet using xswd
+  secure: false, // uses "wss://" prefix (secure websocket) when true. Useful to connect to a remote node under an "https://" scheme.
+  debug: true, // debug mode enabled. will print a lot of messages to console.
+};
+
+// fallback should point to a node so that blockchain data or SC data can be pulled even if the wallet is not connected
+const fallback_config /*: Config */ = { 
+  address: "127.0.0.1",
+  port: 20000, // example for simulator node
+  secure: false, 
+  // debug attribute here will be ignored
+}
+      
+const xswd = new Api(appInfo, config, fallback_config);
+
+await xswd.initializeFallback();
+await xswd.initializeXSWD(); // if this one succeeds, the fallback connection will be closed.
+
+```
+
+#### Handle closing websocket
+
+If the websocket connection is closed, the `onclose` callback will be called.
+
+```js
+// set a handler for the websocket closing
+xswd.onclose = function(connectionType/* : ConnectionType */, closeEvent /* : CloseEvent */) {
+  if (connectionType == "xswd" /* connectionType == ConnectionType.XSWD */) {
+    console.error("Connection was closed!", closeEvent)
+  }
+}
 ```
 
 #### Calls
diff --git a/node_modules/dero-xswd-api/dist/index.d.mts b/node_modules/dero-xswd-api/dist/index.d.mts
index 65436ab..ca42002 100644
--- a/node_modules/dero-xswd-api/dist/index.d.mts
+++ b/node_modules/dero-xswd-api/dist/index.d.mts
@@ -1,3 +1,5 @@
+import { Chan } from '@lesomnus/channel';
+
 type Uint64 = number;
 type DVMString = string;
 type Hash = string;
@@ -8,6 +10,24 @@ type Stringkeys = {
     [key: string]: number | string;
 };
 type Entity = "wallet" | "daemon";
+type Config = {
+    address?: string;
+    port?: number;
+    debug?: boolean;
+    timeout?: {
+        AUTH_TIMEOUT?: number;
+        METHOD_TIMEOUT?: number;
+        BLOCK_TIMEOUT?: number;
+    };
+    secure?: boolean;
+};
+declare enum ConnectionState {
+    Initializing = "initializing",
+    WaitingAuth = "waitingAuth",
+    Accepted = "accepted",
+    Refused = "refused",
+    Closed = "closed"
+}
 type AppInfo = {
     id: string;
     name: string;
@@ -386,102 +406,53 @@ type DEROGetEncryptedBalanceResult = {
     dtreehash: Hash;
 } & Status;
 
-declare enum ConnectionState {
-    Initializing = "initializing",
-    WaitingAuth = "waitingAuth",
-    Accepted = "accepted",
-    Refused = "refused",
-    Closed = "closed"
-}
-declare abstract class Connection {
-    id: number;
-    AUTH_TIMEOUT: number | null;
-    METHOD_TIMEOUT: number | null;
-    BLOCK_TIMEOUT: number | null;
-    INTERVAL: number;
-    constructor();
-    abstract initialize(): Promise<void>;
-    abstract close(): void;
-    abstract onclose(): void;
-    abstract sendSync<E extends Entity, M extends Method<E>>(entity: E, method: M, body: Omit<JSONRPCRequestBody<typeof entity, typeof method>, "id">): Promise<Response<E, M, "error"> | Response<E, M, "result">>;
-    abstract _checkEvent(eventType: EventType, predicate?: (eventValue: any) => boolean): Promise<any>;
+declare enum ConnectionType {
+    XSWD = "xswd",
+    Fallback = "fallback"
 }
-declare class XSWDConnection extends Connection {
-    websocket: WebSocket | undefined;
-    ip: string;
-    port: number;
-    state: ConnectionState;
-    responses: {
-        [id: number]: null | any;
+declare class Api {
+    connection: {
+        [ct in ConnectionType]: WebSocket | null;
     };
-    events: {
-        [eventType: EventType | string]: {
-            processed: boolean;
-            value: any;
-            subscribed: false | "auto" | "permanent";
-            callback?: (value: any) => void;
-        };
+    state: {
+        [ct in ConnectionType]: ConnectionState;
     };
-    appInfo: AppInfo;
     buffer: string;
-    timeouts: Set<any>;
-    constructor(appInfo: AppInfo, config?: Config);
-    close(): Promise<void>;
-    onclose(): void;
-    initialize(): Promise<void>;
-    private authorize;
-    private handle;
-    private handleEvent;
-    private send;
-    sendSync<E extends Entity, M extends Method<E>>(entity: E, method: M, body: Omit<JSONRPCRequestBody<typeof entity, typeof method>, "id">): Promise<Response<E, M, "error"> | Response<E, M, "result">>;
-    private _checkResponse;
-    _checkEvent(eventType: EventType, predicate?: (eventValue: any) => boolean): Promise<any>;
-}
-declare class FallbackConnection extends Connection {
-    url: string;
-    events: {};
-    constructor(url: string, config?: {
-        debug?: boolean;
-    });
-    sendSync<E extends Entity, M extends Method<E>>(entity: E, method: M, body: Omit<JSONRPCRequestBody<E, M>, "id">): Promise<Response<E, M, "error"> | Response<E, M, "result">>;
-    initialize(): Promise<void>;
-    close(): void;
-    onclose(): void;
-    send(entity: Entity, method: Method<Entity>, body: Omit<JSONRPCRequestBody<Entity, Method<Entity>>, "id">): number;
-    _checkEvent(eventType: EventType, predicate?: ((eventValue: any) => boolean) | undefined): Promise<any>;
-}
-
-type Config = {
-    ip?: string;
-    port?: number;
-    debug?: boolean;
-    timeout?: {
-        AUTH_TIMEOUT?: number;
-        METHOD_TIMEOUT?: number;
-        BLOCK_TIMEOUT?: number;
+    appInfo: AppInfo;
+    config: {
+        [k in ConnectionType]: k extends ConnectionType.XSWD ? Config : Config | null;
     };
-};
-declare class Api {
-    _connection: Connection;
-    _xswd_connection: XSWDConnection;
-    status: {
-        initialized: false;
-    } | {
-        initialized: true;
-        fallback: boolean;
+    response: Chan<Response<Entity, Method<Entity>, Result>>;
+    subscriptions: {
+        events: {
+            [et in EventType]: {
+                enabled: boolean;
+                waiting: Chan<any>[];
+                callback?: (eventValue?: any) => void;
+            };
+        };
     };
-    _fallback_connection: FallbackConnection | null;
-    fallback_http_rpc: string | null;
-    appInfo: AppInfo;
-    config: Config;
-    constructor(appInfo: AppInfo, config?: Config, fallback_http_rpc?: false | null | undefined | string);
+    private nextId;
+    get mode(): ConnectionType;
+    constructor(appInfo: AppInfo, config?: Config, fallback_config?: Config | null);
     initialize(): Promise<void>;
+    initializeFallback(): Promise<void>;
+    initializeXSWD(): Promise<void>;
+    _initializeWebsocket(connectionType: ConnectionType): Promise<void>;
+    _handleFragmentedData(message: MessageEvent<any>): AuthResponse | EventResponse | Response<Entity, Method<Entity>, "error"> | Response<Entity, Method<Entity>, "result"> | null;
+    _setupHandlers(connectionType: ConnectionType, resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void): Promise<void>;
+    onclose(connectionType: ConnectionType, ev: CloseEvent): void;
+    closeXSWD(): Promise<void>;
+    closeFallback(): Promise<void>;
     close(): Promise<void>;
-    subscribe({ event, callback }: {
+    Send<E extends Entity, M extends Method<E>>(//! previously sendSync
+    entity: E, method: M, body: Omit<JSONRPCRequestBody<E, M>, "id">): Promise<Response<E, M, "error"> | Response<E, M, "result">>;
+    subscribe({ event, callback, }: {
         event: EventType;
-        callback?: any;
-    }, subscriptionType?: "auto" | "permanent"): Promise<boolean>;
+        callback?: (value: any) => void;
+    }): Promise<boolean>;
     waitFor<ET extends EventType, EV = ET extends "new_balance" ? Balance : ET extends "new_topoheight" ? Topoheight : ET extends "new_entry" ? Entry : unknown>(event: ET, predicate?: (eventValue: EV) => boolean): Promise<EV>;
+    private authorize;
     wallet: {
         _api: Api;
         Echo(params: Echo): Promise<Response<"wallet", "Echo", "error"> | Response<"wallet", "Echo", "result">>;
@@ -519,8 +490,8 @@ declare class Api {
     };
 }
 
-declare function generateAppId(appName: string): Promise<string>;
+declare function generateAppId(appName: string): string;
 declare function sleep(timems: number): Promise<void>;
 declare function to<E extends Entity, M extends Method<E>, R extends Result = Result>(response: Response<E, M, R>): [ErrorResponse | undefined, ResultResponse<E, M> | undefined];
 
-export { Address, Api, AppInfo, AuthResponse, Balance, Config, Connection, ConnectionState, DEROGetBlock, DEROGetBlockHeaderByHash, DEROGetBlockHeaderByTopoHeight, DEROGetBlockTemplate, DEROGetEncryptedBalance, DEROGetGasEstimate, DEROGetRandomAddress, DEROGetSC, DEROGetTransaction, DERONameToAddress, DEROSendRawTransaction, DVMString, DataType, Echo, Entity, Entry, ErrorResponse, EventResponse, EventType, FallbackConnection, GetBalance, GetTrackedAssets, GetTransferbyTXID, GetTransfers, Hash, JSONRPCRequest, JSONRPCRequestBody, MakeIntegratedAddress, Method, Params, QueryKey, Response, Result, ResultResponse, SCCode, SCInvoke, SplitIntegratedAddress, Stringkeys, Topoheight, Transfer, Uint64, WalletTransfer, XSWDConnection, gasEstimateSCArgs, generateAppId, scinvokeSCArgs, sleep, to };
+export { Address, Api, AppInfo, AuthResponse, Balance, Config, ConnectionState, DEROGetBlock, DEROGetBlockHeaderByHash, DEROGetBlockHeaderByTopoHeight, DEROGetBlockTemplate, DEROGetEncryptedBalance, DEROGetGasEstimate, DEROGetRandomAddress, DEROGetSC, DEROGetTransaction, DERONameToAddress, DEROSendRawTransaction, DVMString, DataType, Echo, Entity, Entry, ErrorResponse, EventResponse, EventType, GetBalance, GetTrackedAssets, GetTransferbyTXID, GetTransfers, Hash, JSONRPCRequest, JSONRPCRequestBody, MakeIntegratedAddress, Method, Params, QueryKey, Response, Result, ResultResponse, SCCode, SCInvoke, SplitIntegratedAddress, Stringkeys, Topoheight, Transfer, Uint64, WalletTransfer, gasEstimateSCArgs, generateAppId, scinvokeSCArgs, sleep, to };
diff --git a/node_modules/dero-xswd-api/dist/index.d.ts b/node_modules/dero-xswd-api/dist/index.d.ts
index 65436ab..7a0f78b 100644
--- a/node_modules/dero-xswd-api/dist/index.d.ts
+++ b/node_modules/dero-xswd-api/dist/index.d.ts
@@ -1,3 +1,5 @@
+import { Chan } from '@lesomnus/channel';
+
 type Uint64 = number;
 type DVMString = string;
 type Hash = string;
@@ -8,6 +10,24 @@ type Stringkeys = {
     [key: string]: number | string;
 };
 type Entity = "wallet" | "daemon";
+type Config = {
+    address?: string;
+    port?: number;
+    debug?: boolean;
+    timeout?: {
+        AUTH_TIMEOUT?: number;
+        METHOD_TIMEOUT?: number;
+        BLOCK_TIMEOUT?: number;
+    };
+    secure?: boolean;
+};
+declare enum ConnectionState {
+    Initializing = "initializing",
+    WaitingAuth = "waitingAuth",
+    Accepted = "accepted",
+    Refused = "refused",
+    Closed = "closed"
+}
 type AppInfo = {
     id: string;
     name: string;
@@ -386,102 +406,53 @@ type DEROGetEncryptedBalanceResult = {
     dtreehash: Hash;
 } & Status;
 
-declare enum ConnectionState {
-    Initializing = "initializing",
-    WaitingAuth = "waitingAuth",
-    Accepted = "accepted",
-    Refused = "refused",
-    Closed = "closed"
-}
-declare abstract class Connection {
-    id: number;
-    AUTH_TIMEOUT: number | null;
-    METHOD_TIMEOUT: number | null;
-    BLOCK_TIMEOUT: number | null;
-    INTERVAL: number;
-    constructor();
-    abstract initialize(): Promise<void>;
-    abstract close(): void;
-    abstract onclose(): void;
-    abstract sendSync<E extends Entity, M extends Method<E>>(entity: E, method: M, body: Omit<JSONRPCRequestBody<typeof entity, typeof method>, "id">): Promise<Response<E, M, "error"> | Response<E, M, "result">>;
-    abstract _checkEvent(eventType: EventType, predicate?: (eventValue: any) => boolean): Promise<any>;
+declare enum ConnectionType {
+    XSWD = "xswd",
+    Fallback = "fallback"
 }
-declare class XSWDConnection extends Connection {
-    websocket: WebSocket | undefined;
-    ip: string;
-    port: number;
-    state: ConnectionState;
-    responses: {
-        [id: number]: null | any;
+declare class Api {
+    connection: {
+        [ct in ConnectionType]: WebSocket | null;
     };
-    events: {
-        [eventType: EventType | string]: {
-            processed: boolean;
-            value: any;
-            subscribed: false | "auto" | "permanent";
-            callback?: (value: any) => void;
-        };
+    state: {
+        [ct in ConnectionType]: ConnectionState;
     };
-    appInfo: AppInfo;
     buffer: string;
-    timeouts: Set<any>;
-    constructor(appInfo: AppInfo, config?: Config);
-    close(): Promise<void>;
-    onclose(): void;
-    initialize(): Promise<void>;
-    private authorize;
-    private handle;
-    private handleEvent;
-    private send;
-    sendSync<E extends Entity, M extends Method<E>>(entity: E, method: M, body: Omit<JSONRPCRequestBody<typeof entity, typeof method>, "id">): Promise<Response<E, M, "error"> | Response<E, M, "result">>;
-    private _checkResponse;
-    _checkEvent(eventType: EventType, predicate?: (eventValue: any) => boolean): Promise<any>;
-}
-declare class FallbackConnection extends Connection {
-    url: string;
-    events: {};
-    constructor(url: string, config?: {
-        debug?: boolean;
-    });
-    sendSync<E extends Entity, M extends Method<E>>(entity: E, method: M, body: Omit<JSONRPCRequestBody<E, M>, "id">): Promise<Response<E, M, "error"> | Response<E, M, "result">>;
-    initialize(): Promise<void>;
-    close(): void;
-    onclose(): void;
-    send(entity: Entity, method: Method<Entity>, body: Omit<JSONRPCRequestBody<Entity, Method<Entity>>, "id">): number;
-    _checkEvent(eventType: EventType, predicate?: ((eventValue: any) => boolean) | undefined): Promise<any>;
-}
-
-type Config = {
-    ip?: string;
-    port?: number;
-    debug?: boolean;
-    timeout?: {
-        AUTH_TIMEOUT?: number;
-        METHOD_TIMEOUT?: number;
-        BLOCK_TIMEOUT?: number;
+    appInfo: AppInfo;
+    config: {
+        [k in ConnectionType]: k extends ConnectionType.XSWD ? Config : Config | null;
     };
-};
-declare class Api {
-    _connection: Connection;
-    _xswd_connection: XSWDConnection;
-    status: {
-        initialized: false;
-    } | {
-        initialized: true;
-        fallback: boolean;
+    response: Chan<Response<Entity, Method<Entity>, Result>>;
+    subscriptions: {
+        events: {
+            [et in EventType]: {
+                enabled: boolean;
+                waiting: Chan<any>[];
+                callback?: (eventValue?: any) => void;
+            };
+        };
     };
-    _fallback_connection: FallbackConnection | null;
-    fallback_http_rpc: string | null;
-    appInfo: AppInfo;
-    config: Config;
-    constructor(appInfo: AppInfo, config?: Config, fallback_http_rpc?: false | null | undefined | string);
+    private nextId;
+    get mode(): ConnectionType;
+    constructor(appInfo: AppInfo, config?: Config, fallback_config?: Config | null);
     initialize(): Promise<void>;
+    initializeFallback(): Promise<void>;
+    initializeXSWD(): Promise<void>;
+    _initializeWebsocket(connectionType: ConnectionType): Promise<void>;
+    _handleFragmentedData(message: MessageEvent<any>): AuthResponse | EventResponse | Response<Entity, Method<Entity>, "error"> | Response<Entity, Method<Entity>, "result"> | null;
+    _setupHandlers(connectionType: ConnectionType, resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void): Promise<void>;
+    onclose(connectionType: ConnectionType, ev: CloseEvent): void;
+    closeXSWD(): Promise<void>;
+    closeFallback(): Promise<void>;
     close(): Promise<void>;
-    subscribe({ event, callback }: {
+    Send<E extends Entity, M extends Method<E>>(//! previously sendSync
+    entity: E, method: M, body: Omit<JSONRPCRequestBody<E, M>, "id">): Promise<Response<E, M, "error"> | Response<E, M, "result">>;
+    subscribe({ event, callback, }: {
         event: EventType;
-        callback?: any;
-    }, subscriptionType?: "auto" | "permanent"): Promise<boolean>;
+        callback?: (value: any) => void;
+    }): Promise<boolean>;
     waitFor<ET extends EventType, EV = ET extends "new_balance" ? Balance : ET extends "new_topoheight" ? Topoheight : ET extends "new_entry" ? Entry : unknown>(event: ET, predicate?: (eventValue: EV) => boolean): Promise<EV>;
+    private authorize;
     wallet: {
         _api: Api;
         Echo(params: Echo): Promise<Response<"wallet", "Echo", "error"> | Response<"wallet", "Echo", "result">>;
@@ -513,14 +484,14 @@ declare class Api {
         GetLastBlockHeader(): Promise<Response<"daemon", "DERO.GetLastBlockHeader", "error"> | Response<"daemon", "DERO.GetLastBlockHeader", "result">>;
         GetBlockTemplate(params: DEROGetBlockTemplate): Promise<Response<"daemon", "DERO.GetBlockTemplate", "error"> | Response<"daemon", "DERO.GetBlockTemplate", "result">>;
         GetEncryptedBalance(params: DEROGetEncryptedBalance): Promise<Response<"daemon", "DERO.GetEncryptedBalance", "error"> | Response<"daemon", "DERO.GetEncryptedBalance", "result">>;
-        GetSC(params: DEROGetSC, waitAfterNewBlock?: true): Promise<Response<"daemon", "DERO.GetSC", "error"> | Response<"daemon", "DERO.GetSC", "result">>;
+        GetSC(params: DEROGetSC, waitAfterNewBlock?: boolean): Promise<Response<"daemon", "DERO.GetSC", "error"> | Response<"daemon", "DERO.GetSC", "result">>;
         GetGasEstimate(params: DEROGetGasEstimate): Promise<Response<"daemon", "DERO.GetGasEstimate", "error"> | Response<"daemon", "DERO.GetGasEstimate", "result">>;
         NameToAddress(params: DERONameToAddress): Promise<Response<"daemon", "DERO.NameToAddress", "error"> | Response<"daemon", "DERO.NameToAddress", "result">>;
     };
 }
 
-declare function generateAppId(appName: string): Promise<string>;
+declare function generateAppId(appName: string): string;
 declare function sleep(timems: number): Promise<void>;
 declare function to<E extends Entity, M extends Method<E>, R extends Result = Result>(response: Response<E, M, R>): [ErrorResponse | undefined, ResultResponse<E, M> | undefined];
 
-export { Address, Api, AppInfo, AuthResponse, Balance, Config, Connection, ConnectionState, DEROGetBlock, DEROGetBlockHeaderByHash, DEROGetBlockHeaderByTopoHeight, DEROGetBlockTemplate, DEROGetEncryptedBalance, DEROGetGasEstimate, DEROGetRandomAddress, DEROGetSC, DEROGetTransaction, DERONameToAddress, DEROSendRawTransaction, DVMString, DataType, Echo, Entity, Entry, ErrorResponse, EventResponse, EventType, FallbackConnection, GetBalance, GetTrackedAssets, GetTransferbyTXID, GetTransfers, Hash, JSONRPCRequest, JSONRPCRequestBody, MakeIntegratedAddress, Method, Params, QueryKey, Response, Result, ResultResponse, SCCode, SCInvoke, SplitIntegratedAddress, Stringkeys, Topoheight, Transfer, Uint64, WalletTransfer, XSWDConnection, gasEstimateSCArgs, generateAppId, scinvokeSCArgs, sleep, to };
+export { Address, Api, AppInfo, AuthResponse, Balance, Config, ConnectionState, DEROGetBlock, DEROGetBlockHeaderByHash, DEROGetBlockHeaderByTopoHeight, DEROGetBlockTemplate, DEROGetEncryptedBalance, DEROGetGasEstimate, DEROGetRandomAddress, DEROGetSC, DEROGetTransaction, DERONameToAddress, DEROSendRawTransaction, DVMString, DataType, Echo, Entity, Entry, ErrorResponse, EventResponse, EventType, GetBalance, GetTrackedAssets, GetTransferbyTXID, GetTransfers, Hash, JSONRPCRequest, JSONRPCRequestBody, MakeIntegratedAddress, Method, Params, QueryKey, Response, Result, ResultResponse, SCCode, SCInvoke, SplitIntegratedAddress, Stringkeys, Topoheight, Transfer, Uint64, WalletTransfer, gasEstimateSCArgs, generateAppId, scinvokeSCArgs, sleep, to };
diff --git a/node_modules/dero-xswd-api/dist/index.js b/node_modules/dero-xswd-api/dist/index.js
index 101ace3..475ed68 100644
--- a/node_modules/dero-xswd-api/dist/index.js
+++ b/node_modules/dero-xswd-api/dist/index.js
@@ -21,10 +21,7 @@ var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: tru
 var src_exports = {};
 __export(src_exports, {
   Api: () => Api,
-  Connection: () => Connection,
   ConnectionState: () => ConnectionState,
-  FallbackConnection: () => FallbackConnection,
-  XSWDConnection: () => XSWDConnection,
   gasEstimateSCArgs: () => gasEstimateSCArgs,
   generateAppId: () => generateAppId,
   scinvokeSCArgs: () => scinvokeSCArgs,
@@ -33,22 +30,33 @@ __export(src_exports, {
 });
 module.exports = __toCommonJS(src_exports);
 
+// src/types/types.ts
+var ConnectionState = /* @__PURE__ */ ((ConnectionState2) => {
+  ConnectionState2["Initializing"] = "initializing";
+  ConnectionState2["WaitingAuth"] = "waitingAuth";
+  ConnectionState2["Accepted"] = "accepted";
+  ConnectionState2["Refused"] = "refused";
+  ConnectionState2["Closed"] = "closed";
+  return ConnectionState2;
+})(ConnectionState || {});
+
 // src/debug.ts
 var debug_default = (DEBUG) => (label) => DEBUG ? (...data) => console.log(label + ":", ...data) : () => {
 };
 
+// src/xswd.ts
+var import_channel = require("@lesomnus/channel");
+
 // src/utils.ts
-async function hash(message) {
-  const encoder = new TextEncoder();
-  const data = encoder.encode(message);
-  const hash2 = await crypto.subtle.digest("SHA-256", data);
-  return buf2hex(hash2);
-}
-function buf2hex(buffer) {
-  return [...new Uint8Array(buffer)].map((x) => x.toString(16).padStart(2, "0")).join("");
+function pseudoHash(message, length = 64) {
+  message = new Array(64 - message.length).fill(0).map((_) => message).join("");
+  console.assert(message.length > 1, "message length must be > 1");
+  return [...message].map(
+    (char, i) => Math.floor(char.charCodeAt(0) * ((7 + i) / (1 + i % 7))).toString(16)
+  ).join("").slice(0, 64);
 }
-async function generateAppId(appName) {
-  return await hash(appName);
+function generateAppId(appName) {
+  return pseudoHash(appName);
 }
 async function sleep(timems) {
   await new Promise((r) => setTimeout(r, timems));
@@ -60,397 +68,143 @@ function to(response) {
   ];
 }
 
-// src/connection.ts
-var debug = debug_default(false)("connection");
-var ConnectionState = /* @__PURE__ */ ((ConnectionState2) => {
-  ConnectionState2["Initializing"] = "initializing";
-  ConnectionState2["WaitingAuth"] = "waitingAuth";
-  ConnectionState2["Accepted"] = "accepted";
-  ConnectionState2["Refused"] = "refused";
-  ConnectionState2["Closed"] = "closed";
-  return ConnectionState2;
-})(ConnectionState || {});
-var Connection = class {
-  constructor() {
-    this.id = 1;
-    this.AUTH_TIMEOUT = null;
-    this.METHOD_TIMEOUT = null;
-    this.BLOCK_TIMEOUT = null;
-    this.INTERVAL = 100;
-  }
-};
-var XSWDConnection = class extends Connection {
-  constructor(appInfo, config) {
-    super();
-    this.state = "initializing" /* Initializing */;
-    this.responses = {};
-    this.events = {
-      new_topoheight: {
-        processed: true,
-        value: 0,
-        subscribed: false
-      },
-      new_balance: {
-        processed: true,
-        value: 0,
-        subscribed: false
-      },
-      new_entry: {
-        processed: true,
-        value: "",
-        subscribed: false
-      }
-    };
-    this.buffer = "";
-    this.timeouts = /* @__PURE__ */ new Set();
-    debug = debug_default(config?.debug || false)("connection");
-    this.appInfo = appInfo;
-    this.ip = config?.ip || "localhost";
-    this.port = config?.port || 44326;
-    this.AUTH_TIMEOUT = config?.timeout?.AUTH_TIMEOUT || null;
-    this.BLOCK_TIMEOUT = config?.timeout?.BLOCK_TIMEOUT || null;
-    this.METHOD_TIMEOUT = config?.timeout?.METHOD_TIMEOUT || null;
-  }
-  async close() {
-    console.warn("closing websocket", this.timeouts);
-    this.timeouts.forEach((timeout) => clearTimeout(timeout));
-    this.websocket?.close();
-  }
-  onclose() {
-  }
-  async initialize() {
-    return new Promise((resolve, reject) => {
-      debug("initialize");
-      if (this.websocket !== void 0 && this.websocket.readyState == WebSocket.OPEN) {
-        throw "WebSocket is aleady alive";
-      }
-      this.state = "initializing" /* Initializing */;
-      const url = `ws://${this.ip}:${this.port}/xswd`;
-      this.websocket = new WebSocket(url);
-      debug("websocket created for " + url);
-      this.websocket.onmessage = (message) => {
-        let data;
-        try {
-          data = JSON.parse(message.data.toString());
-          debug("WebSocket:onmessage", { data });
-        } catch (error) {
-          this.buffer = this.buffer + message.data.toString();
-          try {
-            data = JSON.parse(this.buffer);
-            this.buffer = "";
-          } catch (error2) {
-            return;
-          }
-        }
-        if ("accepted" in data) {
-          if (data.accepted === true) {
-            this.state = "accepted" /* Accepted */;
-            debug("connection accepted");
-            resolve();
-          } else if (data.accepted === false) {
-            this.state = "refused" /* Refused */;
-            debug("connection refused", data);
-            reject("connection refused: " + data.message);
-          }
-        } else if ("error" in data) {
-          const errorData = data;
-          reject(errorData.error.message);
-          this.handle(data);
-        } else if ("result" in data) {
-          if (typeof data.result == "object" && data.result !== null && "event" in data.result) {
-            this.handleEvent(data);
-          } else {
-            this.handle(data);
-          }
-        }
-      };
-      this.websocket.onerror = (error) => {
-        this.state = "closed" /* Closed */;
-        reject(error);
-      };
-      this.websocket.onopen = () => {
-        debug("websocket connection opened, authorizing...");
-        this.authorize(this.appInfo);
-        this.state = "waitingAuth" /* WaitingAuth */;
-        if (this.AUTH_TIMEOUT) {
-          setTimeout(() => reject("authorisation timeout"), this.AUTH_TIMEOUT);
-        }
-      };
-      this.websocket.onclose = () => {
-        this.state = "initializing" /* Initializing */;
-        this.websocket = void 0;
-        this.onclose();
-        debug("connection closed");
-        reject("connection closed");
-      };
-      debug("websocket handlers are set");
-    });
-  }
-  authorize(appInfo) {
-    const data = { ...appInfo };
-    debug("sending authorisation: ", { data });
-    this.websocket?.send(JSON.stringify(data));
-  }
-  handle(data) {
-    this.responses[Number(data.id)] = data;
-  }
-  handleEvent(data) {
-    this.events[data.result.event].value = data.result.value;
-    this.events[data.result.event].processed = false;
-    const callback = this.events[data.result.event].callback;
-    debug("Handling event", { data, callback });
-    if (callback) {
-      callback(data.result.value);
-    }
-  }
-  send(entity, method, body) {
-    debug("\n\n----------- REQUEST -------", entity, method, "\n");
-    if (this.state == "accepted" /* Accepted */) {
-      const id = this.id;
-      this.id += 1;
-      const bodyWithId = {
-        ...body,
-        id
-      };
-      this.websocket?.send(JSON.stringify(bodyWithId));
-      this.responses[id] = null;
-      return id;
-    } else {
-      throw "sending without being connected";
-    }
-  }
-  async sendSync(entity, method, body) {
-    debug("sendSync:", { body });
-    const id = this.send(entity, method, body);
-    await this._checkResponse(id);
-    const data = this.responses[id];
-    debug("Response:");
-    debug(data);
-    delete this.responses[id];
-    return data;
-  }
-  _checkResponse(id) {
-    return new Promise(async (resolve, reject) => {
-      let timeout;
-      if (this.METHOD_TIMEOUT) {
-        timeout = setTimeout(() => {
-          this.timeouts.delete(timeout);
-          reject("request timeout");
-        }, this.METHOD_TIMEOUT);
-        this.timeouts.add(timeout);
-      }
-      for (let attempts = 1; ; attempts++) {
-        await sleep(this.INTERVAL * attempts);
-        debug("checking response", id);
-        if (this.responses[id] !== null && this.responses[id] !== void 0) {
-          debug(`response ${id}`, this.responses[id]);
-          if (timeout !== void 0) {
-            this.timeouts.delete(timeout);
-          }
-          resolve();
-          break;
-        }
-      }
-    });
-  }
-  // TODO Typing
-  _checkEvent(eventType, predicate) {
-    return new Promise(async (resolve, reject) => {
-      let timeout;
-      if (this.BLOCK_TIMEOUT) {
-        timeout = setTimeout(() => {
-          this.timeouts.delete(timeout);
-          reject("event check timeout");
-        }, this.BLOCK_TIMEOUT);
-        this.timeouts.add(timeout);
-      }
-      for (let attempts = 1; ; attempts++) {
-        await sleep(this.INTERVAL * attempts);
-        debug("checking event", eventType);
-        if (predicate === void 0 || predicate(this.events[eventType].value)) {
-          if (!this.events[eventType].processed) {
-            this.events[eventType].processed = true;
-            debug("checked event", eventType);
-            if (timeout !== void 0) {
-              this.timeouts.delete(timeout);
-            }
-            resolve(this.events[eventType].value);
-            break;
-          }
-        }
-      }
-    });
-  }
-};
-var FallbackConnection = class extends Connection {
-  constructor(url, config) {
-    super();
-    this.events = {};
-    debug = debug_default(config?.debug || false)("connection");
-    this.url = `${url}/json_rpc`;
-  }
-  async sendSync(entity, method, body) {
-    const id = this.id++;
-    const bodyWithId = {
-      ...body,
-      id
-    };
-    debug({ bodyWithId });
-    const response = await fetch(this.url, {
-      method: "POST",
-      headers: {
-        "Content-Type": "application/json"
-      },
-      body: JSON.stringify(bodyWithId)
-    });
-    const json = await response.json();
-    debug({ response: json });
-    return json;
-  }
-  //
-  // Inactive methods
-  //
-  initialize() {
-    throw "Connection.initialize() shall not be used in fallback mode";
-  }
-  close() {
-  }
-  onclose() {
-  }
-  send(entity, method, body) {
-    throw "Connection.send() shall not be used in fallback mode";
-  }
-  _checkEvent(eventType, predicate) {
-    throw "Connection._checkEvent() shall not be used in fallback mode";
-  }
-};
-
 // src/xswd.ts
-var debug2 = debug_default(false)("xswd");
-var DEFAULT_FALLBACK_CONFIG = "dero-api.mysrv.cloud:443";
-var DEFAULT_CONFIG = { ip: "localhost", port: 44326 };
+var debug = debug_default(false)("xswd");
+var DEFAULT_CONFIG = {
+  address: "127.0.0.1",
+  port: 44326,
+  secure: false,
+  debug: false
+};
 var DEFAULT_TIMEOUT = {
   AUTH_TIMEOUT: void 0,
   METHOD_TIMEOUT: void 0,
   BLOCK_TIMEOUT: void 0
 };
+var CHECK_INTERVAL = 500;
+function checkConfig(config) {
+  if (!config.address) {
+    throw "missing address in fallback config";
+  }
+}
 var Api = class {
-  constructor(appInfo, config, fallback_http_rpc = DEFAULT_FALLBACK_CONFIG) {
-    this.status = {
-      initialized: false
+  constructor(appInfo, config, fallback_config = null) {
+    this.connection = {
+      xswd: null,
+      fallback: null
+    };
+    this.state = {
+      xswd: "closed" /* Closed */,
+      fallback: "closed" /* Closed */
+    };
+    this.buffer = "";
+    this.response = new import_channel.Chan(0);
+    this.subscriptions = {
+      events: {
+        new_topoheight: {
+          enabled: false,
+          waiting: [],
+          callback: void 0
+        },
+        new_entry: {
+          enabled: false,
+          waiting: [],
+          callback: void 0
+        },
+        new_balance: {
+          enabled: false,
+          waiting: [],
+          callback: void 0
+        }
+      }
     };
-    this._fallback_connection = null;
-    this.fallback_http_rpc = null;
+    this.nextId = 1;
     this.wallet = {
       _api: this,
       async Echo(params) {
-        return await this._api._connection.sendSync("wallet", "Echo", {
+        return await this._api.Send("wallet", "Echo", {
           jsonrpc: "2.0",
           method: "Echo",
           params
         });
       },
       async GetAddress() {
-        return await this._api._connection.sendSync("wallet", "GetAddress", {
+        return await this._api.Send("wallet", "GetAddress", {
           jsonrpc: "2.0",
           method: "GetAddress",
           params: void 0
         });
       },
       async GetBalance(params = {}) {
-        return await this._api._connection.sendSync("wallet", "GetBalance", {
+        return await this._api.Send("wallet", "GetBalance", {
           jsonrpc: "2.0",
           method: "GetBalance",
           params
         });
       },
       async GetHeight() {
-        return await this._api._connection.sendSync("wallet", "GetHeight", {
+        return await this._api.Send("wallet", "GetHeight", {
           jsonrpc: "2.0",
           method: "GetHeight",
           params: void 0
         });
       },
       async GetTransferbyTXID(params) {
-        return await this._api._connection.sendSync(
-          "wallet",
-          "GetTransferbyTXID",
-          {
-            jsonrpc: "2.0",
-            method: "GetTransferbyTXID",
-            params
-          }
-        );
+        return await this._api.Send("wallet", "GetTransferbyTXID", {
+          jsonrpc: "2.0",
+          method: "GetTransferbyTXID",
+          params
+        });
       },
       async GetTransfers(params = {}) {
-        return await this._api._connection.sendSync("wallet", "GetTransfers", {
+        return await this._api.Send("wallet", "GetTransfers", {
           jsonrpc: "2.0",
           method: "GetTransfers",
           params
         });
       },
       async GetTrackedAssets(params) {
-        return await this._api._connection.sendSync(
-          "wallet",
-          "GetTrackedAssets",
-          {
-            jsonrpc: "2.0",
-            method: "GetTrackedAssets",
-            params
-          }
-        );
+        return await this._api.Send("wallet", "GetTrackedAssets", {
+          jsonrpc: "2.0",
+          method: "GetTrackedAssets",
+          params
+        });
       },
       async MakeIntegratedAddress(params) {
-        return await this._api._connection.sendSync(
-          "wallet",
-          "MakeIntegratedAddress",
-          {
-            jsonrpc: "2.0",
-            method: "MakeIntegratedAddress",
-            params
-          }
-        );
+        return await this._api.Send("wallet", "MakeIntegratedAddress", {
+          jsonrpc: "2.0",
+          method: "MakeIntegratedAddress",
+          params
+        });
       },
       async SplitIntegratedAddress(params) {
-        return await this._api._connection.sendSync(
-          "wallet",
-          "SplitIntegratedAddress",
-          {
-            jsonrpc: "2.0",
-            method: "SplitIntegratedAddress",
-            params
-          }
-        );
+        return await this._api.Send("wallet", "SplitIntegratedAddress", {
+          jsonrpc: "2.0",
+          method: "SplitIntegratedAddress",
+          params
+        });
       },
       async QueryKey(params) {
-        return await this._api._connection.sendSync("wallet", "QueryKey", {
+        return await this._api.Send("wallet", "QueryKey", {
           jsonrpc: "2.0",
           method: "QueryKey",
           params
         });
       },
       async transfer(params) {
-        const response = await this._api._connection.sendSync(
-          "wallet",
-          "transfer",
-          {
-            jsonrpc: "2.0",
-            method: "transfer",
-            params
-          }
-        );
+        const response = await this._api.Send("wallet", "transfer", {
+          jsonrpc: "2.0",
+          method: "transfer",
+          params
+        });
         return response;
       },
       async scinvoke(params) {
-        const response = await this._api._connection.sendSync(
-          "wallet",
-          "scinvoke",
-          {
-            jsonrpc: "2.0",
-            method: "scinvoke",
-            params
-          }
-        );
+        const response = await this._api.Send("wallet", "scinvoke", {
+          jsonrpc: "2.0",
+          method: "scinvoke",
+          params
+        });
         if ("error" in response) {
           throw "could not scinvoke: " + response.error.message;
         }
@@ -460,86 +214,70 @@ var Api = class {
     this.node = {
       _api: this,
       async Echo(params) {
-        return await this._api._connection.sendSync("daemon", "DERO.Echo", {
+        return await this._api.Send("daemon", "DERO.Echo", {
           jsonrpc: "2.0",
           method: "DERO.Echo",
           params
         });
       },
       async Ping() {
-        return await this._api._connection.sendSync("daemon", "DERO.Ping", {
+        return await this._api.Send("daemon", "DERO.Ping", {
           jsonrpc: "2.0",
           method: "DERO.Ping",
           params: void 0
         });
       },
       async GetInfo() {
-        return await this._api._connection.sendSync("daemon", "DERO.GetInfo", {
+        return await this._api.Send("daemon", "DERO.GetInfo", {
           jsonrpc: "2.0",
           method: "DERO.GetInfo",
           params: void 0
         });
       },
       async GetBlock(params) {
-        return await this._api._connection.sendSync("daemon", "DERO.GetBlock", {
+        return await this._api.Send("daemon", "DERO.GetBlock", {
           jsonrpc: "2.0",
           method: "DERO.GetBlock",
           params
         });
       },
       async GetBlockHeaderByTopoHeight(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetBlockHeaderByTopoHeight",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetBlockHeaderByTopoHeight",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetBlockHeaderByTopoHeight", {
+          jsonrpc: "2.0",
+          method: "DERO.GetBlockHeaderByTopoHeight",
+          params
+        });
       },
       async GetBlockHeaderByHash(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetBlockHeaderByHash",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetBlockHeaderByHash",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetBlockHeaderByHash", {
+          jsonrpc: "2.0",
+          method: "DERO.GetBlockHeaderByHash",
+          params
+        });
       },
       async GetTxPool() {
-        return await this._api._connection.sendSync("daemon", "DERO.GetTxPool", {
+        return await this._api.Send("daemon", "DERO.GetTxPool", {
           jsonrpc: "2.0",
           method: "DERO.GetTxPool",
           params: void 0
         });
       },
       async GetRandomAddress(params = {}) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetRandomAddress",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetRandomAddress",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetRandomAddress", {
+          jsonrpc: "2.0",
+          method: "DERO.GetRandomAddress",
+          params
+        });
       },
       async GetTransaction(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetTransaction",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetTransaction",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetTransaction", {
+          jsonrpc: "2.0",
+          method: "DERO.GetTransaction",
+          params
+        });
       },
       /*async SendRawTransaction(params: DEROSendRawTransaction) {
-        return await this._api._connection.sendSync(
+        return await this._api.sendSync(
           "daemon",
           "DERO.SendRawTransaction",
           {
@@ -550,139 +288,316 @@ var Api = class {
         );
       },*/
       async GetHeight() {
-        return await this._api._connection.sendSync("daemon", "DERO.GetHeight", {
+        return await this._api.Send("daemon", "DERO.GetHeight", {
           jsonrpc: "2.0",
           method: "DERO.GetHeight",
           params: void 0
         });
       },
       async GetBlockCount() {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetBlockCount",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetBlockCount",
-            params: void 0
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetBlockCount", {
+          jsonrpc: "2.0",
+          method: "DERO.GetBlockCount",
+          params: void 0
+        });
       },
       async GetLastBlockHeader() {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetLastBlockHeader",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetLastBlockHeader",
-            params: void 0
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetLastBlockHeader", {
+          jsonrpc: "2.0",
+          method: "DERO.GetLastBlockHeader",
+          params: void 0
+        });
       },
       async GetBlockTemplate(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetBlockTemplate",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetBlockTemplate",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetBlockTemplate", {
+          jsonrpc: "2.0",
+          method: "DERO.GetBlockTemplate",
+          params
+        });
       },
       async GetEncryptedBalance(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetEncryptedBalance",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetEncryptedBalance",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetEncryptedBalance", {
+          jsonrpc: "2.0",
+          method: "DERO.GetEncryptedBalance",
+          params
+        });
       },
       async GetSC(params, waitAfterNewBlock) {
         if (waitAfterNewBlock) {
-          debug2("waiting for new block");
-          this._api.subscribe({ event: "new_topoheight" }, "auto");
+          debug("waiting for new block");
+          this._api.subscribe({ event: "new_topoheight" });
           await this._api.waitFor("new_topoheight");
         }
-        return await this._api._connection.sendSync("daemon", "DERO.GetSC", {
+        return await this._api.Send("daemon", "DERO.GetSC", {
           jsonrpc: "2.0",
           method: "DERO.GetSC",
           params
         });
       },
       async GetGasEstimate(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetGasEstimate",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetGasEstimate",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetGasEstimate", {
+          jsonrpc: "2.0",
+          method: "DERO.GetGasEstimate",
+          params
+        });
       },
       async NameToAddress(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.NameToAddress",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.NameToAddress",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.NameToAddress", {
+          jsonrpc: "2.0",
+          method: "DERO.NameToAddress",
+          params
+        });
       }
     };
-    debug2 = debug_default(config?.debug || false)("xswd");
-    debug2("creating connection");
+    debug = debug_default(config?.debug || false)("xswd");
+    debug("creating connection");
     checkAppInfo(appInfo);
     this.appInfo = appInfo;
+    if (fallback_config) {
+      checkConfig(fallback_config);
+      debug("configured fallback:", fallback_config);
+    }
     this.config = {
-      ...DEFAULT_CONFIG,
-      ...config || {},
-      timeout: { ...DEFAULT_TIMEOUT, ...config?.timeout || {} }
+      xswd: {
+        ...DEFAULT_CONFIG,
+        ...config || {},
+        timeout: { ...DEFAULT_TIMEOUT, ...config?.timeout || {} }
+      },
+      fallback: fallback_config
     };
-    this._xswd_connection = new XSWDConnection(appInfo, config);
-    this._connection = this._xswd_connection;
-    if (fallback_http_rpc) {
-      this.fallback_http_rpc = fallback_http_rpc;
-      this._fallback_connection = new FallbackConnection(fallback_http_rpc, {
-        debug: config?.debug || false
+  }
+  get mode() {
+    return this.state.xswd == "accepted" /* Accepted */ ? "xswd" /* XSWD */ : this.state.fallback != "accepted" /* Accepted */ ? "xswd" /* XSWD */ : "fallback" /* Fallback */;
+  }
+  // deprecated
+  async initialize() {
+    debug("initializing api");
+    if (this.config.fallback) {
+      await this.initializeFallback().finally(async () => {
+        await this.initializeXSWD();
       });
-      this._connection = this._fallback_connection;
-      this.status = { initialized: true, fallback: true };
+    } else {
+      await this.initializeXSWD();
     }
   }
-  async initialize() {
-    this._xswd_connection = new XSWDConnection(this.appInfo, this.config);
-    await this._xswd_connection.initialize();
-    this.status = { initialized: true, fallback: false };
-    this._connection = this._xswd_connection;
+  async initializeFallback() {
+    return new Promise(async (resolve, reject) => {
+      debug("initializing fallback");
+      if (this.config.fallback) {
+        this._initializeWebsocket("fallback" /* Fallback */).then(() => {
+          debug("fallback intitialized");
+          resolve();
+        }).catch((error) => {
+          console.warn("failed to initialize fallback:", error);
+          reject(error);
+        });
+      } else {
+        reject("fallback has no config");
+      }
+    });
   }
-  async close() {
-    if (this.status.initialized) {
-      this._connection.close();
+  async initializeXSWD() {
+    return new Promise(async (resolve, reject) => {
+      debug("initializing xswd");
+      this._initializeWebsocket("xswd" /* XSWD */).then(() => {
+        debug("xswd initialized");
+        this.closeFallback();
+        resolve();
+      }).catch((error) => {
+        if (this.state.fallback == "accepted" /* Accepted */) {
+          console.warn("failed to initialize xswd. staying in fallback mode");
+          console.error(error);
+          reject(error);
+        } else {
+          console.error("failed to initialize xswd or fallback:", error);
+          reject(error);
+        }
+      });
+    });
+  }
+  async _initializeWebsocket(connectionType) {
+    return new Promise((resolve, reject) => {
+      debug("initialize " + connectionType);
+      const websocket = this.connection[connectionType];
+      if (websocket !== null && websocket.readyState == WebSocket.OPEN) {
+        throw "WebSocket is aleady alive";
+      }
+      this.state[connectionType] = "initializing" /* Initializing */;
+      const config = this.config[connectionType];
+      if (config != null) {
+        const protocol = config.secure ? "wss" : "ws";
+        const port = config.port ? `:${config.port}` : "";
+        const path = connectionType == "xswd" /* XSWD */ ? "xswd" : "ws";
+        const url = `${protocol}://${config.address}${port}/${path}`;
+        this.connection[connectionType] = new WebSocket(url);
+        debug(connectionType + " websocket created for " + url);
+        this._setupHandlers(connectionType, resolve, reject);
+      }
+    });
+  }
+  _handleFragmentedData(message) {
+    try {
+      return JSON.parse(message.data.toString());
+    } catch (error) {
+      this.buffer = this.buffer + message.data.toString();
+      try {
+        const data = JSON.parse(this.buffer);
+        this.buffer = "";
+        return data;
+      } catch (error2) {
+        return null;
+      }
     }
   }
-  async subscribe({ event, callback }, subscriptionType = "permanent") {
-    if (this.status.initialized && this._connection instanceof XSWDConnection) {
-      const subscription = await this._connection.sendSync(
-        "wallet",
-        "Subscribe",
-        {
-          jsonrpc: "2.0",
-          method: "Subscribe",
-          params: { event }
+  async _setupHandlers(connectionType, resolve, reject) {
+    const websocket = this.connection[connectionType];
+    if (websocket) {
+      websocket.onmessage = async (message) => {
+        let data;
+        data = this._handleFragmentedData(message);
+        if (data == null)
+          return;
+        if (connectionType == "xswd" /* XSWD */) {
+          if ("accepted" in data) {
+            if (data.accepted === true) {
+              this.state["xswd" /* XSWD */] = "accepted" /* Accepted */;
+              debug("connection accepted");
+              resolve();
+            } else if (data.accepted === false) {
+              this.state["xswd" /* XSWD */] = "refused" /* Refused */;
+              debug("connection refused", data);
+              reject("connection refused: " + data.message);
+            }
+          }
+        }
+        if ("error" in data) {
+          const errorData = data;
+          await this.response.send(errorData);
+          reject(errorData.error.message);
+        } else if ("result" in data) {
+          if (connectionType == "xswd" /* XSWD */ && typeof data.result == "object" && data.result != null && "event" in data.result) {
+            const eventData = data;
+            const eventType = eventData.result.event;
+            const eventValue = eventData.result.value;
+            if (this.subscriptions.events[eventType].enabled) {
+              const callback = this.subscriptions.events[eventType].callback;
+              if (callback !== void 0)
+                callback(eventValue);
+              this.subscriptions.events[eventType].waiting.forEach(
+                (waitingChannel) => {
+                  waitingChannel.send(eventValue);
+                }
+              );
+              return;
+            }
+          }
+          await this.response.send(data);
+        }
+      };
+      websocket.onerror = (error) => {
+        this.state[connectionType] = "closed" /* Closed */;
+        reject(error);
+      };
+      websocket.onopen = () => {
+        if (connectionType == "fallback" /* Fallback */) {
+          debug("fallback websocket connection opened.");
+          resolve();
+          this.state[connectionType] = "accepted" /* Accepted */;
+        } else {
+          debug("xswd websocket connection opened, authorizing...");
+          this.authorize(this.appInfo);
+          this.state.xswd = "waitingAuth" /* WaitingAuth */;
+          if (this.config.xswd.timeout?.AUTH_TIMEOUT) {
+            setTimeout(
+              () => reject("authorisation timeout"),
+              this.config.xswd.timeout?.AUTH_TIMEOUT
+            );
+          }
+        }
+      };
+      websocket.onclose = (ev) => {
+        this.state[connectionType] = "closed" /* Closed */;
+        this.connection[connectionType] = null;
+        this.onclose(connectionType, ev);
+        debug(connectionType + " connection closed");
+        reject(connectionType + " connection closed");
+      };
+      debug(connectionType + " websocket handlers are set");
+    }
+  }
+  // callback meant to be set by user
+  onclose(connectionType, ev) {
+  }
+  async closeXSWD() {
+    if (this.state.xswd == "accepted" /* Accepted */ || this.state.xswd == "waitingAuth" /* WaitingAuth */) {
+      debug("closing xswd");
+      this.connection.xswd?.close();
+      this.state.xswd = "closed" /* Closed */;
+    }
+  }
+  async closeFallback() {
+    if (this.state.fallback == "accepted" /* Accepted */) {
+      debug("closing fallback");
+      this.connection.fallback?.close();
+      this.state.fallback = "closed" /* Closed */;
+    }
+  }
+  async close() {
+    this.closeFallback();
+    this.closeXSWD();
+  }
+  async Send(entity, method, body) {
+    return new Promise(
+      async (resolve, reject) => {
+        if (this.mode == "fallback" /* Fallback */ && entity == "wallet") {
+          reject("cannot send to wallet in fallback mode.");
         }
-      );
+        debug("\n\n----------- REQUEST -------", entity, method, "\n");
+        const websocket = this.connection[this.mode];
+        if (this.state[this.mode] == "accepted" /* Accepted */ && websocket) {
+          const id = this.nextId;
+          this.nextId += 1;
+          const bodyWithId = {
+            ...body,
+            id
+          };
+          debug("sending", bodyWithId);
+          websocket.send(JSON.stringify(bodyWithId));
+          for (; ; ) {
+            const response = await this.response.recv();
+            if (response.id != String(id)) {
+              debug("id mismatch: ", response.id, String(id), ", resetting");
+              await this.response.send(response);
+              await sleep(CHECK_INTERVAL);
+            } else {
+              debug("id match", { response });
+              resolve(
+                response
+              );
+              return;
+            }
+          }
+        } else {
+          reject("sending without being connected");
+          return;
+        }
+      }
+    );
+  }
+  async subscribe({
+    event,
+    callback
+  }) {
+    if (this.state.xswd == "accepted" /* Accepted */ && this.mode === "xswd" /* XSWD */) {
+      const subscription = await this.Send("wallet", "Subscribe", {
+        jsonrpc: "2.0",
+        method: "Subscribe",
+        params: { event }
+      });
       if ("result" in subscription) {
         if (subscription.result) {
-          this._connection.events[event].subscribed = subscriptionType;
-          if (subscriptionType == "permanent") {
-            this._connection.events[event].callback = callback;
-          }
+          this.subscriptions.events[event].enabled = true;
+          this.subscriptions.events[event].callback = callback;
         }
         return subscription.result;
       }
@@ -692,13 +607,34 @@ var Api = class {
     return false;
   }
   async waitFor(event, predicate) {
-    if (this.status.initialized) {
-      return await this._connection._checkEvent(event, predicate);
+    if (this.mode == "fallback" /* Fallback */) {
+      throw "cannot wait for event in fallback mode";
+    }
+    if (!this.subscriptions.events[event].enabled) {
+      throw `event ${event} has not been subscribed to`;
     }
-    if (this._connection instanceof XSWDConnection) {
+    if (this.state.xswd == "accepted" /* Accepted */) {
+      const c = new import_channel.Chan();
+      this.subscriptions.events[event].waiting.push(c);
+      for (; ; ) {
+        const value = await c.recv();
+        if (predicate === void 0) {
+          return value;
+        } else if (predicate && predicate(value)) {
+          return value;
+        }
+      }
+    } else {
       throw "cannot wait for event if connection is not initialized";
     }
-    throw "cannot wait for event in fallback mode";
+  }
+  authorize(appInfo) {
+    const websocket = this.connection.xswd;
+    if (websocket) {
+      const data = { ...appInfo };
+      debug("sending authorisation: ", { data });
+      websocket.send(JSON.stringify(data));
+    }
   }
 };
 function checkAppInfo(appInfo) {
@@ -750,10 +686,7 @@ function scinvokeSCArgs(entrypoint, args) {
 // Annotate the CommonJS export names for ESM import in node:
 0 && (module.exports = {
   Api,
-  Connection,
   ConnectionState,
-  FallbackConnection,
-  XSWDConnection,
   gasEstimateSCArgs,
   generateAppId,
   scinvokeSCArgs,
diff --git a/node_modules/dero-xswd-api/dist/index.js.map b/node_modules/dero-xswd-api/dist/index.js.map
index 925d364..16a4436 100644
--- a/node_modules/dero-xswd-api/dist/index.js.map
+++ b/node_modules/dero-xswd-api/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/index.ts","../src/debug.ts","../src/utils.ts","../src/connection.ts","../src/xswd.ts","../src/types/request.ts"],"sourcesContent":["export * from \"./xswd\";\nexport * from \"./utils\";\nexport * from \"./types/request\";\nexport * from \"./types/response\";\nexport * from \"./connection\";\nexport * from \"./types/types\";\n","export default (DEBUG: boolean) => (label: string) =>\n  DEBUG ? (...data: any) => console.log(label + \":\", ...data) : () => {};\n","import {\n  ErrorResponse,\n  Response,\n  Result,\n  ResultResponse,\n} from \"./types/response\";\nimport { Entity } from \"./types/types\";\nimport { Method } from \"./types/request\";\n\nasync function hash(message: string) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  const hash = await crypto.subtle.digest(\"SHA-256\", data);\n  return buf2hex(hash);\n}\nfunction buf2hex(buffer: ArrayBuffer) {\n  return [...new Uint8Array(buffer)]\n    .map((x) => x.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n}\n\nexport async function generateAppId(appName: string): Promise<string> {\n  return await hash(appName);\n}\n\nexport async function sleep(timems: number) {\n  await new Promise((r) => setTimeout(r, timems));\n}\n\nexport function to<\n  E extends Entity,\n  M extends Method<E>,\n  R extends Result = Result\n>(\n  response: Response<E, M, R>\n): [ErrorResponse | undefined, ResultResponse<E, M> | undefined] {\n  return [\n    \"error\" in response ? (response.error as ErrorResponse) : undefined,\n    \"result\" in response\n      ? (response.result as ResultResponse<E, M>)\n      : undefined,\n  ];\n}\n","import { Method, JSONRPCRequestBody } from \"./types/request\";\nimport { AuthResponse, EventResponse, Response } from \"./types/response\";\nimport { AppInfo, Entity, EventType } from \"./types/types\";\n\nimport makeDebug from \"./debug\";\nimport { sleep } from \"./utils\";\nimport { Config } from \"./xswd\";\nlet debug = makeDebug(false)(\"connection\");\n\nexport enum ConnectionState {\n  Initializing = \"initializing\",\n  WaitingAuth = \"waitingAuth\",\n  Accepted = \"accepted\",\n  Refused = \"refused\",\n  Closed = \"closed\",\n}\n\nabstract class Connection {\n  id = 1;\n  AUTH_TIMEOUT: number | null = null;\n  METHOD_TIMEOUT: number | null = null;\n  BLOCK_TIMEOUT: number | null = null;\n  INTERVAL = 100;\n  constructor() {}\n  abstract initialize(): Promise<void>;\n  abstract close(): void;\n  abstract onclose(): void;\n\n  abstract sendSync<E extends Entity, M extends Method<E>>(\n    entity: E,\n    method: M,\n    body: Omit<JSONRPCRequestBody<typeof entity, typeof method>, \"id\">\n  ): Promise<Response<E, M, \"error\"> | Response<E, M, \"result\">>;\n\n  abstract _checkEvent(\n    eventType: EventType,\n    predicate?: (eventValue: any) => boolean\n  ): Promise<any>;\n}\n\nclass XSWDConnection extends Connection {\n  websocket: WebSocket | undefined;\n  ip: string;\n  port: number;\n  state = ConnectionState.Initializing;\n  responses: { [id: number]: null | any } = {};\n  events: {\n    [eventType: EventType | string]: {\n      processed: boolean;\n      value: any;\n      subscribed: false | \"auto\" | \"permanent\";\n      callback?: (value: any) => void;\n    };\n  } = {\n    new_topoheight: {\n      processed: true,\n      value: 0,\n      subscribed: false,\n    },\n    new_balance: {\n      processed: true,\n      value: 0,\n      subscribed: false,\n    },\n    new_entry: {\n      processed: true,\n      value: \"\",\n      subscribed: false,\n    },\n  };\n  appInfo: AppInfo;\n  buffer: string = \"\";\n  timeouts: Set<any> = new Set();\n\n  constructor(appInfo: AppInfo, config?: Config) {\n    super();\n    debug = makeDebug(config?.debug || false)(\"connection\");\n    this.appInfo = appInfo;\n\n    this.ip = config?.ip || \"localhost\";\n    this.port = config?.port || 44326;\n\n    this.AUTH_TIMEOUT = config?.timeout?.AUTH_TIMEOUT || null;\n    this.BLOCK_TIMEOUT = config?.timeout?.BLOCK_TIMEOUT || null;\n    this.METHOD_TIMEOUT = config?.timeout?.METHOD_TIMEOUT || null;\n  }\n  async close() {\n    console.warn(\"closing websocket\", this.timeouts);\n\n    this.timeouts.forEach((timeout) => clearTimeout(timeout));\n    this.websocket?.close();\n  }\n\n  onclose(): void {}\n\n  async initialize() {\n    return new Promise<void>((resolve, reject) => {\n      debug(\"initialize\");\n      if (\n        this.websocket !== undefined &&\n        this.websocket.readyState == WebSocket.OPEN\n      ) {\n        throw \"WebSocket is aleady alive\";\n      }\n      this.state = ConnectionState.Initializing;\n\n      const url = `ws://${this.ip}:${this.port}/xswd`;\n      this.websocket = new WebSocket(url);\n      debug(\"websocket created for \" + url);\n\n      this.websocket.onmessage = (message) => {\n        let data:\n          | AuthResponse\n          | EventResponse\n          | Response<Entity, Method<Entity>, \"error\">\n          | Response<Entity, Method<Entity>, \"result\">;\n\n        // fragmented messages handling\n        try {\n          // default parsing a single message\n          data = JSON.parse(message.data.toString());\n          debug(\"WebSocket:onmessage\", { data });\n        } catch (error) {\n          // sometimes the result is split in multiple message so we need to buffer\n          this.buffer = this.buffer + message.data.toString();\n          try {\n            // we keep parsing the buffer after updating it to check if the result is complete\n            data = JSON.parse(this.buffer);\n            // success => we empty the buffer\n            this.buffer = \"\";\n          } catch (error) {\n            // not parsable yet, better luck next message\n            return;\n          }\n        }\n\n        if (\"accepted\" in data) {\n          if (data.accepted === true) {\n            this.state = ConnectionState.Accepted;\n            debug(\"connection accepted\");\n            resolve();\n          } else if (data.accepted === false) {\n            this.state = ConnectionState.Refused;\n            debug(\"connection refused\", data);\n            reject(\"connection refused: \" + data.message);\n          }\n        } else if (\"error\" in data) {\n          const errorData: Response<Entity, Method<Entity>, \"error\"> = data;\n          reject(errorData.error.message);\n          this.handle(data);\n        } else if (\"result\" in data) {\n          if (\n            typeof data.result == \"object\" &&\n            data.result !== null &&\n            \"event\" in data.result\n          ) {\n            this.handleEvent(data as EventResponse);\n          } else {\n            this.handle(data);\n          }\n        }\n      };\n\n      this.websocket.onerror = (error) => {\n        this.state = ConnectionState.Closed;\n        reject(error);\n      };\n\n      this.websocket.onopen = () => {\n        debug(\"websocket connection opened, authorizing...\");\n        this.authorize(this.appInfo);\n        this.state = ConnectionState.WaitingAuth;\n        if (this.AUTH_TIMEOUT) {\n          setTimeout(() => reject(\"authorisation timeout\"), this.AUTH_TIMEOUT);\n        }\n      };\n\n      this.websocket.onclose = () => {\n        this.state = ConnectionState.Initializing;\n        this.websocket = undefined;\n        this.onclose();\n        debug(\"connection closed\");\n        reject(\"connection closed\");\n      };\n\n      debug(\"websocket handlers are set\");\n    });\n  }\n\n  private authorize(appInfo: AppInfo) {\n    const data = { ...appInfo };\n    debug(\"sending authorisation: \", { data });\n    this.websocket?.send(JSON.stringify(data));\n  }\n  private handle(data: any) {\n    this.responses[Number(data.id)] = data;\n  }\n\n  private handleEvent(data: EventResponse) {\n    this.events[data.result.event].value = data.result.value;\n    this.events[data.result.event].processed = false;\n    const callback = this.events[data.result.event].callback;\n    debug(\"Handling event\", { data, callback });\n\n    if (callback) {\n      callback(data.result.value);\n    }\n  }\n\n  private send(\n    entity: Entity,\n    method: Method<typeof entity>,\n    body: Omit<JSONRPCRequestBody<typeof entity, typeof method>, \"id\">\n  ): number {\n    debug(\"\\n\\n----------- REQUEST -------\", entity, method, \"\\n\");\n    if (this.state == ConnectionState.Accepted) {\n      const id = this.id;\n      this.id += 1;\n      const bodyWithId: JSONRPCRequestBody<typeof entity, typeof method> = {\n        ...body,\n        id,\n      };\n\n      this.websocket?.send(JSON.stringify(bodyWithId));\n      this.responses[id] = null;\n      return id;\n    } else {\n      throw \"sending without being connected\";\n    }\n  }\n\n  async sendSync<E extends Entity, M extends Method<E>>(\n    entity: E,\n    method: M,\n    body: Omit<JSONRPCRequestBody<typeof entity, typeof method>, \"id\">\n  ): Promise<Response<E, M, \"error\"> | Response<E, M, \"result\">> {\n    debug(\"sendSync:\", { body });\n\n    const id = this.send(entity, method, body);\n\n    await this._checkResponse(id);\n    const data = this.responses[id];\n\n    debug(\"Response:\");\n    debug(data);\n    /*if (\"result\" in data) {\n      if (\"stringkeys\" in data.result) {\n        if (\"C\" in data.result.stringkeys) {\n          debug({\n            ...data,\n            result: {\n              ...data.result,\n              stringkeys: { ...data.result.stringkeys, C: \"...\" },\n            },\n          });\n          //delete data.result.stringkeys.C;\n        }\n      }\n    }*/\n\n    delete this.responses[id];\n\n    return data;\n  }\n\n  private _checkResponse(id: number) {\n    return new Promise<void>(async (resolve, reject) => {\n      // setup a timeout for response checking\n      let timeout: any;\n      if (this.METHOD_TIMEOUT) {\n        timeout = setTimeout(() => {\n          // delete the timeout record\n          this.timeouts.delete(timeout);\n          reject(\"request timeout\");\n        }, this.METHOD_TIMEOUT);\n\n        // record this timeout (if we close we need to clear the handles)\n        this.timeouts.add(timeout);\n      }\n      // loop over time to see if the event has been received\n      for (let attempts = 1; ; attempts++) {\n        await sleep(this.INTERVAL * attempts); // double the time at each new attempts\n        debug(\"checking response\", id);\n\n        // if event hasn't already been processed\n        if (this.responses[id] !== null && this.responses[id] !== undefined) {\n          // handle\n          debug(`response ${id}`, this.responses[id]);\n          if (timeout !== undefined) {\n            this.timeouts.delete(timeout);\n          }\n          resolve();\n          break;\n        }\n      }\n    });\n  }\n\n  // TODO Typing\n  _checkEvent(\n    eventType: EventType,\n    predicate?: (eventValue: any) => boolean\n  ): Promise<any> {\n    return new Promise<any>(async (resolve, reject) => {\n      let timeout: any;\n      if (this.BLOCK_TIMEOUT) {\n        // setup a timeout for event checking\n        timeout = setTimeout(() => {\n          // delete the timeout record\n          this.timeouts.delete(timeout);\n          reject(\"event check timeout\");\n        }, this.BLOCK_TIMEOUT);\n\n        // record this timeout (if we close we need to clear the handles)\n        this.timeouts.add(timeout);\n      }\n      // loop over time to see if the event has been received\n      for (let attempts = 1; ; attempts++) {\n        await sleep(this.INTERVAL * attempts); // double the time at each new attempts\n        debug(\"checking event\", eventType);\n\n        // if there is no predicate or this is the target\n        if (predicate === undefined || predicate(this.events[eventType].value))\n          if (!this.events[eventType].processed) {\n            // if event hasn't already been processed\n            // handle\n            this.events[eventType].processed = true;\n            debug(\"checked event\", eventType);\n            if (timeout !== undefined) {\n              this.timeouts.delete(timeout);\n            }\n            resolve(this.events[eventType].value);\n            break;\n          }\n      }\n    });\n  }\n}\n\nclass FallbackConnection extends Connection {\n  url: string;\n  events = {};\n\n  constructor(url: string, config?: { debug?: boolean }) {\n    super();\n    debug = makeDebug(config?.debug || false)(\"connection\");\n    this.url = `${url}/json_rpc`;\n  }\n\n  async sendSync<E extends Entity, M extends Method<E>>(\n    entity: E,\n    method: M,\n    body: Omit<JSONRPCRequestBody<E, M>, \"id\">\n  ): Promise<Response<E, M, \"error\"> | Response<E, M, \"result\">> {\n    const id = this.id++;\n    const bodyWithId: JSONRPCRequestBody<Entity, Method<Entity>> = {\n      ...body,\n      id,\n    };\n\n    debug({ bodyWithId });\n    const response = await fetch(this.url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(bodyWithId),\n    });\n\n    const json = await response.json();\n\n    debug({ response: json }); // TODO\n\n    return json;\n  }\n\n  //\n  // Inactive methods\n  //\n\n  initialize(): Promise<void> {\n    throw \"Connection.initialize() shall not be used in fallback mode\";\n  }\n  close(): void {}\n  onclose(): void {}\n  send(\n    entity: Entity,\n    method: Method<Entity>,\n    body: Omit<JSONRPCRequestBody<Entity, Method<Entity>>, \"id\">\n  ): number {\n    throw \"Connection.send() shall not be used in fallback mode\";\n  }\n  _checkEvent(\n    eventType: EventType,\n    predicate?: ((eventValue: any) => boolean) | undefined\n  ): Promise<any> {\n    throw \"Connection._checkEvent() shall not be used in fallback mode\";\n  }\n}\n\nexport { XSWDConnection, Connection, FallbackConnection };\n","import { Connection, FallbackConnection, XSWDConnection } from \"./connection\";\nimport {\n  Echo,\n  GetTransferbyTXID,\n  GetTransfers,\n  MakeIntegratedAddress,\n  QueryKey,\n  SplitIntegratedAddress,\n  SCInvoke,\n  DEROGetBlock,\n  DEROGetBlockHeaderByHash,\n  DEROGetBlockHeaderByTopoHeight,\n  DEROGetBlockTemplate,\n  DEROGetEncryptedBalance,\n  DEROGetGasEstimate,\n  DEROGetRandomAddress,\n  DEROGetSC,\n  DEROGetTransaction,\n  DERONameToAddress,\n  Transfer,\n  GetBalance,\n  GetTrackedAssets,\n} from \"./types/request\";\nimport { AppInfo, EventType } from \"./types/types\";\nimport makeDebug from \"./debug\";\nimport { Entry, Balance, Topoheight } from \"./types/response\";\n\nlet debug = makeDebug(false)(\"xswd\");\n\nconst DEFAULT_FALLBACK_CONFIG = \"dero-api.mysrv.cloud:443\";\nconst DEFAULT_CONFIG = { ip: \"localhost\", port: 44326 };\nconst DEFAULT_TIMEOUT = {\n  AUTH_TIMEOUT: undefined,\n  METHOD_TIMEOUT: undefined,\n  BLOCK_TIMEOUT: undefined,\n};\n\nexport type Config = {\n  ip?: string;\n  port?: number;\n  debug?: boolean;\n  timeout?: {\n    AUTH_TIMEOUT?: number;\n    METHOD_TIMEOUT?: number;\n    BLOCK_TIMEOUT?: number;\n  };\n};\n\n// https://dero-api.mysrv.cloud/json_rpc\n// dero-node-ca.mysrv.cloud:10102\n// ams.derofoundation.org:11011\n// 213.171.208.37:18089 (MySrvCloud)\n// 5.161.123.196:11011 (MySrvCloud VA)\n// 51.222.86.51:11011 (RabidMining Pool)\n// 74.208.54.173:50404 (deronfts)\n// 85.214.253.170:53387 (mmarcel-vps)\n// 163.172.26.245:10505 (DeroStats)\n// 44.198.24.170:20000 (pieswap)\n\nexport class Api {\n  _connection: Connection;\n  _xswd_connection: XSWDConnection;\n  status: { initialized: false } | { initialized: true; fallback: boolean } = {\n    initialized: false,\n  };\n  _fallback_connection: FallbackConnection | null = null;\n  fallback_http_rpc: string | null = null;\n  appInfo: AppInfo;\n  config: Config;\n\n  constructor(\n    appInfo: AppInfo,\n    config?: Config,\n    // if xswd fails to connect, at least connect to a public node\n    fallback_http_rpc:\n      | false // any falsy means deactivate fallback\n      | null\n      | undefined\n      | string = DEFAULT_FALLBACK_CONFIG // or the default fallback value\n  ) {\n    debug = makeDebug(config?.debug || false)(\"xswd\");\n    debug(\"creating connection\");\n    checkAppInfo(appInfo);\n    this.appInfo = appInfo;\n    this.config = {\n      ...DEFAULT_CONFIG,\n      ...(config || {}),\n      timeout: { ...DEFAULT_TIMEOUT, ...(config?.timeout || {}) },\n    };\n    this._xswd_connection = new XSWDConnection(appInfo, config);\n    this._connection = this._xswd_connection;\n\n    if (fallback_http_rpc) {\n      this.fallback_http_rpc = fallback_http_rpc;\n      this._fallback_connection = new FallbackConnection(fallback_http_rpc, {\n        debug: config?.debug || false,\n      });\n      this._connection = this._fallback_connection;\n      this.status = { initialized: true, fallback: true };\n    }\n    /**\n\n   */\n  }\n\n  async initialize() {\n    this._xswd_connection = new XSWDConnection(this.appInfo, this.config);\n\n    await this._xswd_connection.initialize();\n    this.status = { initialized: true, fallback: false };\n    this._connection = this._xswd_connection;\n  }\n\n  async close() {\n    if (this.status.initialized) {\n      this._connection.close();\n    }\n  }\n\n  async subscribe(\n    { event, callback }: { event: EventType; callback?: any },\n    subscriptionType: \"auto\" | \"permanent\" = \"permanent\"\n  ) {\n    if (this.status.initialized && this._connection instanceof XSWDConnection) {\n      const subscription = await this._connection.sendSync(\n        \"wallet\",\n        \"Subscribe\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"Subscribe\",\n          params: { event },\n        }\n      );\n      if (\"result\" in subscription) {\n        if (subscription.result) {\n          this._connection.events[event].subscribed = subscriptionType;\n          // dont overwrite user callback\n          if (subscriptionType == \"permanent\") {\n            this._connection.events[event].callback = callback;\n          }\n        }\n        return subscription.result;\n      }\n      return false;\n    }\n    console.warn(\"cannot subscibe to events in fallback mode\");\n    return false;\n  }\n\n  async waitFor<\n    ET extends EventType,\n    EV = ET extends \"new_balance\"\n      ? Balance\n      : ET extends \"new_topoheight\"\n      ? Topoheight\n      : ET extends \"new_entry\"\n      ? Entry\n      : unknown\n  >(event: ET, predicate?: (eventValue: EV) => boolean): Promise<EV> {\n    if (this.status.initialized) {\n      return await this._connection._checkEvent(event, predicate);\n    }\n    if (this._connection instanceof XSWDConnection) {\n      throw \"cannot wait for event if connection is not initialized\";\n    }\n    throw \"cannot wait for event in fallback mode\";\n  }\n\n  wallet = {\n    _api: this as Api,\n\n    async Echo(params: Echo) {\n      return await this._api._connection.sendSync(\"wallet\", \"Echo\", {\n        jsonrpc: \"2.0\",\n        method: \"Echo\",\n        params,\n      });\n    },\n    async GetAddress() {\n      return await this._api._connection.sendSync(\"wallet\", \"GetAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"GetAddress\",\n        params: undefined,\n      });\n    },\n    async GetBalance(params: GetBalance = {}) {\n      return await this._api._connection.sendSync(\"wallet\", \"GetBalance\", {\n        jsonrpc: \"2.0\",\n        method: \"GetBalance\",\n        params,\n      });\n    },\n    async GetHeight() {\n      return await this._api._connection.sendSync(\"wallet\", \"GetHeight\", {\n        jsonrpc: \"2.0\",\n        method: \"GetHeight\",\n        params: undefined,\n      });\n    },\n    async GetTransferbyTXID(params: GetTransferbyTXID) {\n      return await this._api._connection.sendSync(\n        \"wallet\",\n        \"GetTransferbyTXID\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"GetTransferbyTXID\",\n          params,\n        }\n      );\n    },\n    async GetTransfers(params: GetTransfers = {}) {\n      return await this._api._connection.sendSync(\"wallet\", \"GetTransfers\", {\n        jsonrpc: \"2.0\",\n        method: \"GetTransfers\",\n        params,\n      });\n    },\n\n    async GetTrackedAssets(params: GetTrackedAssets) {\n      return await this._api._connection.sendSync(\n        \"wallet\",\n        \"GetTrackedAssets\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"GetTrackedAssets\",\n          params,\n        }\n      );\n    },\n\n    async MakeIntegratedAddress(params: MakeIntegratedAddress) {\n      return await this._api._connection.sendSync(\n        \"wallet\",\n        \"MakeIntegratedAddress\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"MakeIntegratedAddress\",\n          params,\n        }\n      );\n    },\n    async SplitIntegratedAddress(params: SplitIntegratedAddress) {\n      return await this._api._connection.sendSync(\n        \"wallet\",\n        \"SplitIntegratedAddress\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"SplitIntegratedAddress\",\n          params,\n        }\n      );\n    },\n    async QueryKey(params: QueryKey) {\n      return await this._api._connection.sendSync(\"wallet\", \"QueryKey\", {\n        jsonrpc: \"2.0\",\n        method: \"QueryKey\",\n        params,\n      });\n    },\n    async transfer(params: Transfer) {\n      const response = await this._api._connection.sendSync(\n        \"wallet\",\n        \"transfer\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"transfer\",\n          params,\n        }\n      );\n      return response;\n    },\n    async scinvoke(params: SCInvoke) {\n      const response = await this._api._connection.sendSync(\n        \"wallet\",\n        \"scinvoke\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"scinvoke\",\n          params,\n        }\n      );\n\n      if (\"error\" in response) {\n        throw \"could not scinvoke: \" + response.error.message;\n      }\n\n      return response;\n    },\n  };\n  node = {\n    _api: this as Api,\n\n    async Echo(params: Echo) {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.Echo\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.Echo\",\n        params,\n      });\n    },\n    async Ping() {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.Ping\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.Ping\",\n        params: undefined,\n      });\n    },\n    async GetInfo() {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.GetInfo\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetInfo\",\n        params: undefined,\n      });\n    },\n    async GetBlock(params: DEROGetBlock) {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.GetBlock\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlock\",\n        params,\n      });\n    },\n    async GetBlockHeaderByTopoHeight(params: DEROGetBlockHeaderByTopoHeight) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetBlockHeaderByTopoHeight\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetBlockHeaderByTopoHeight\",\n          params,\n        }\n      );\n    },\n    async GetBlockHeaderByHash(params: DEROGetBlockHeaderByHash) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetBlockHeaderByHash\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetBlockHeaderByHash\",\n          params,\n        }\n      );\n    },\n    async GetTxPool() {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.GetTxPool\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetTxPool\",\n        params: undefined,\n      });\n    },\n    async GetRandomAddress(params: DEROGetRandomAddress = {}) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetRandomAddress\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetRandomAddress\",\n          params,\n        }\n      );\n    },\n    async GetTransaction(params: DEROGetTransaction) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetTransaction\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetTransaction\",\n          params,\n        }\n      );\n    },\n    /*async SendRawTransaction(params: DEROSendRawTransaction) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.SendRawTransaction\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.SendRawTransaction\",\n          params,\n        }\n      );\n    },*/\n    async GetHeight() {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.GetHeight\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetHeight\",\n        params: undefined,\n      });\n    },\n    async GetBlockCount() {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetBlockCount\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetBlockCount\",\n          params: undefined,\n        }\n      );\n    },\n    async GetLastBlockHeader() {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetLastBlockHeader\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetLastBlockHeader\",\n          params: undefined,\n        }\n      );\n    },\n    async GetBlockTemplate(params: DEROGetBlockTemplate) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetBlockTemplate\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetBlockTemplate\",\n          params,\n        }\n      );\n    },\n    async GetEncryptedBalance(params: DEROGetEncryptedBalance) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetEncryptedBalance\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetEncryptedBalance\",\n          params,\n        }\n      );\n    },\n    async GetSC(params: DEROGetSC, waitAfterNewBlock?: true) {\n      if (waitAfterNewBlock) {\n        debug(\"waiting for new block\");\n        this._api.subscribe({ event: \"new_topoheight\" }, \"auto\");\n        await this._api.waitFor(\"new_topoheight\");\n      }\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.GetSC\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetSC\",\n        params,\n      });\n    },\n    async GetGasEstimate(params: DEROGetGasEstimate) {\n      // use gasEstimateSCArgs() to simplify usage\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetGasEstimate\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetGasEstimate\",\n          params,\n        }\n      );\n    },\n    async NameToAddress(params: DERONameToAddress) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.NameToAddress\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.NameToAddress\",\n          params,\n        }\n      );\n    },\n  };\n}\n\nfunction checkAppInfo(appInfo: AppInfo) {\n  if (appInfo.name !== undefined && appInfo.name.length == 0) {\n    throw \"invalid app name\";\n  }\n  if (appInfo.description !== undefined && appInfo.description.length == 0) {\n    throw \"invalid app description\";\n  }\n  if (appInfo.id !== undefined && appInfo.id.length != 64) {\n    throw \"invalid app id\";\n  }\n}\n","import {\n  Address,\n  DVMString,\n  Entity,\n  EventType,\n  Hash,\n  SCCode,\n  Uint64,\n} from \"./types\";\n\nexport type JSONRPCRequest = {\n  method: \"POST\";\n  headers: {\n    \"Content-Type\": \"application/json\";\n  };\n  body: JSONRPCRequestBody<Entity, Method<Entity>>;\n};\n\nexport type JSONRPCRequestBody<E extends Entity, M extends Method<E>> = {\n  jsonrpc: \"2.0\";\n  id: string | number;\n  method: M;\n  params: Params<E, M>;\n};\n\nexport type Method<E extends Entity> = E extends \"daemon\"\n  ?\n      | \"DERO.Echo\"\n      | \"DERO.Ping\"\n      | \"DERO.GetInfo\"\n      | \"DERO.GetBlock\"\n      | \"DERO.GetBlockHeaderByTopoHeight\"\n      | \"DERO.GetBlockHeaderByHash\"\n      | \"DERO.GetTxPool\"\n      | \"DERO.GetRandomAddress\"\n      | \"DERO.GetTransaction\"\n      | \"DERO.SendRawTransaction\"\n      | \"DERO.GetHeight\"\n      | \"DERO.GetBlockCount\"\n      | \"DERO.GetLastBlockHeader\"\n      | \"DERO.GetBlockTemplate\"\n      | \"DERO.GetEncryptedBalance\"\n      | \"DERO.GetSC\"\n      | \"DERO.GetGasEstimate\"\n      | \"DERO.NameToAddress\"\n  :\n      | \"Echo\"\n      | \"GetAddress\"\n      | \"GetBalance\"\n      | \"GetHeight\"\n      | \"GetTransferbyTXID\"\n      | \"GetTransfers\"\n      | \"GetTrackedAssets\"\n      | \"MakeIntegratedAddress\"\n      | \"SplitIntegratedAddress\"\n      | \"QueryKey\"\n      | \"transfer\"\n      | \"scinvoke\"\n      | \"Subscribe\";\n\nexport type Params<\n  E extends Entity,\n  M extends Method<E>\n> = M extends \"DERO.Echo\"\n  ? Echo\n  : M extends \"DERO.Ping\"\n  ? undefined\n  : M extends \"DERO.GetInfo\"\n  ? undefined\n  : M extends \"DERO.GetBlock\"\n  ? DEROGetBlock\n  : M extends \"DERO.GetBlockHeaderByTopoHeight\"\n  ? DEROGetBlockHeaderByTopoHeight\n  : M extends \"DERO.GetBlockHeaderByHash\"\n  ? DEROGetBlockHeaderByHash\n  : M extends \"DERO.GetTxPool\"\n  ? undefined\n  : M extends \"DERO.GetRandomAddress\"\n  ? DEROGetRandomAddress\n  : M extends \"DERO.GetTransaction\"\n  ? DEROGetTransaction\n  : M extends \"DERO.SendRawTransaction\"\n  ? DEROSendRawTransaction\n  : M extends \"DERO.GetHeight\"\n  ? undefined\n  : M extends \"DERO.GetBlockCount\"\n  ? undefined\n  : M extends \"DERO.GetLastBlockHeader\"\n  ? undefined\n  : M extends \"DERO.GetBlockTemplate\"\n  ? DEROGetBlockTemplate\n  : M extends \"DERO.GetEncryptedBalance\"\n  ? DEROGetEncryptedBalance\n  : M extends \"DERO.GetSC\"\n  ? DEROGetSC\n  : M extends \"DERO.GetGasEstimate\"\n  ? DEROGetGasEstimate\n  : M extends \"DERO.NameToAddress\"\n  ? DERONameToAddress\n  : M extends \"GetAddress\"\n  ? undefined\n  : M extends \"GetBalance\"\n  ? GetBalance\n  : M extends \"GetHeight\"\n  ? undefined\n  : M extends \"GetTrackedAssets\"\n  ? GetTrackedAssets\n  : M extends \"GetTransferbyTXID\"\n  ? GetTransferbyTXID\n  : M extends \"GetTransfers\"\n  ? GetTransfers\n  : M extends \"MakeIntegratedAddress\"\n  ? MakeIntegratedAddress\n  : M extends \"SplitIntegratedAddress\"\n  ? SplitIntegratedAddress\n  : M extends \"QueryKey\"\n  ? QueryKey\n  : M extends \"transfer\"\n  ? Transfer\n  : M extends \"scinvoke\"\n  ? SCInvoke\n  : M extends \"Subscribe\"\n  ? { event: EventType }\n  : Echo;\n\nexport type Echo = DVMString[];\n\nexport type WalletTransfer = {\n  amount?: Uint64;\n  burn?: Uint64;\n  destination?: string;\n  scid?: Hash;\n  payload_rpc?: Arguments;\n};\n\ntype ArgumentType = Uint64 | DVMString | Hash;\ntype Argument<AT extends ArgumentType> = {\n  name: DVMString;\n  datatype: AT extends Uint64\n    ? \"U\"\n    : AT extends Hash | DVMString\n    ? \"H\" | \"S\"\n    : unknown;\n  value: AT;\n};\n\ntype Arguments = Argument<ArgumentType>[];\n\nexport type DEROGetBlock = {\n  hash?: Hash;\n  height?: Uint64;\n};\n\nexport type DEROGetBlockHeaderByTopoHeight = {\n  topoheight: Uint64;\n};\n\nexport type DEROGetBlockHeaderByHash = {\n  hash: Hash;\n};\n\nexport type DEROGetRandomAddress = {\n  scid?: Hash;\n};\n\nexport type DEROGetTransaction = {\n  txs_hashes: Hash[];\n  decode_as_json?: Uint64;\n};\n\nexport type DEROSendRawTransaction = {\n  tx_as_hex: DVMString;\n};\n\nexport type DEROGetBlockTemplate = {\n  wallet_address: DVMString;\n  block?: boolean;\n  miner?: DVMString;\n};\n\nexport type DEROGetEncryptedBalance = {\n  address: DVMString;\n  topoheight: Uint64;\n  scid?: Hash;\n  treehash?: Hash;\n};\n\nexport type DEROGetSC = {\n  scid: Hash;\n  code?: boolean;\n  variables?: boolean;\n  topoheight?: Uint64;\n  keysuint64?: Uint64[];\n  keysstring?: DVMString[];\n  keysbytes?: Int8Array[];\n};\n\n// TODO rename transferSCArgs, used in both transfer and gasEstimate\nexport function gasEstimateSCArgs(\n  scid: Hash,\n  entrypoint: string,\n  args: { name: string; value: DVMString | Uint64 }[]\n): Argument<ArgumentType>[] {\n  return [\n    {\n      name: \"SC_ACTION\",\n      datatype: \"U\",\n      value: 0,\n    },\n    {\n      name: \"SC_ID\",\n      datatype: \"H\",\n      value: scid,\n    },\n    ...scinvokeSCArgs(entrypoint, args),\n  ];\n}\n\nexport function scinvokeSCArgs(\n  entrypoint: string,\n  args: { name: string; value: DVMString | Uint64 }[]\n): Argument<ArgumentType>[] {\n  const formattedArgs: Argument<ArgumentType>[] = args.map(\n    ({ name, value }) => ({\n      name,\n      datatype: typeof value == \"number\" ? \"U\" : \"S\", //? bigint?\n      value,\n    })\n  );\n  return [\n    {\n      name: \"entrypoint\",\n      datatype: \"S\",\n      value: entrypoint,\n    },\n    ...formattedArgs,\n  ];\n}\n\nexport type DEROGetGasEstimate = {\n  transfers?: WalletTransfer[];\n  sc?: SCCode;\n  sc_rpc?: Argument<ArgumentType>[];\n  signer?: Address;\n};\n\nexport type DERONameToAddress = {\n  name: DVMString;\n  topoheight: Uint64;\n};\n\nexport type GetBalance = {\n  scid?: Hash;\n};\n\nexport type GetTrackedAssets = {\n  only_positive_balances: boolean;\n  skip_balance_check: boolean;\n};\n\nexport type GetTransferbyTXID = {\n  hash?: Hash;\n  txid?: Hash;\n};\n\nexport type GetTransfers = {\n  scid?: Hash;\n  coinbase?: boolean;\n  in?: boolean;\n  out?: boolean;\n  min_height?: Uint64;\n  max_height?: Uint64;\n  sender?: DVMString;\n  receiver?: DVMString;\n  dstport?: Uint64;\n  srcport?: Uint64;\n};\n\nexport type MakeIntegratedAddress = {\n  address?: DVMString;\n  payload_rpc?: Argument<ArgumentType>;\n};\n\nexport type SplitIntegratedAddress = {\n  integrated_address: DVMString;\n};\n\nexport type QueryKey = { key_type: \"mnemonic\" };\n\nexport type Transfer = {\n  transfers?: WalletTransfer[];\n  sc?: SCCode;\n  sc_rpc?: Arguments;\n  ringsize?: Uint64;\n  scid?: Hash;\n  fees?: Uint64;\n  signer?: Address;\n};\n\nexport type SCInvoke = {\n  scid: Hash;\n  sc_rpc: Arguments;\n\n  sc_dero_deposit?: Uint64;\n  sc_token_deposit?: Uint64;\n  ringsize?: Uint64;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAO,gBAAQ,CAAC,UAAmB,CAAC,UAClC,QAAQ,IAAI,SAAc,QAAQ,IAAI,QAAQ,KAAK,GAAG,IAAI,IAAI,MAAM;AAAC;;;ACQvE,eAAe,KAAK,SAAiB;AACnC,QAAM,UAAU,IAAI,YAAY;AAChC,QAAM,OAAO,QAAQ,OAAO,OAAO;AACnC,QAAMA,QAAO,MAAM,OAAO,OAAO,OAAO,WAAW,IAAI;AACvD,SAAO,QAAQA,KAAI;AACrB;AACA,SAAS,QAAQ,QAAqB;AACpC,SAAO,CAAC,GAAG,IAAI,WAAW,MAAM,CAAC,EAC9B,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAC1C,KAAK,EAAE;AACZ;AAEA,eAAsB,cAAc,SAAkC;AACpE,SAAO,MAAM,KAAK,OAAO;AAC3B;AAEA,eAAsB,MAAM,QAAgB;AAC1C,QAAM,IAAI,QAAQ,CAAC,MAAM,WAAW,GAAG,MAAM,CAAC;AAChD;AAEO,SAAS,GAKd,UAC+D;AAC/D,SAAO;AAAA,IACL,WAAW,WAAY,SAAS,QAA0B;AAAA,IAC1D,YAAY,WACP,SAAS,SACV;AAAA,EACN;AACF;;;ACnCA,IAAI,QAAQ,cAAU,KAAK,EAAE,YAAY;AAElC,IAAK,kBAAL,kBAAKC,qBAAL;AACL,EAAAA,iBAAA,kBAAe;AACf,EAAAA,iBAAA,iBAAc;AACd,EAAAA,iBAAA,cAAW;AACX,EAAAA,iBAAA,aAAU;AACV,EAAAA,iBAAA,YAAS;AALC,SAAAA;AAAA,GAAA;AAQZ,IAAe,aAAf,MAA0B;AAAA,EAMxB,cAAc;AALd,cAAK;AACL,wBAA8B;AAC9B,0BAAgC;AAChC,yBAA+B;AAC/B,oBAAW;AAAA,EACI;AAejB;AAEA,IAAM,iBAAN,cAA6B,WAAW;AAAA,EAkCtC,YAAY,SAAkB,QAAiB;AAC7C,UAAM;AA/BR,iBAAQ;AACR,qBAA0C,CAAC;AAC3C,kBAOI;AAAA,MACF,gBAAgB;AAAA,QACd,WAAW;AAAA,QACX,OAAO;AAAA,QACP,YAAY;AAAA,MACd;AAAA,MACA,aAAa;AAAA,QACX,WAAW;AAAA,QACX,OAAO;AAAA,QACP,YAAY;AAAA,MACd;AAAA,MACA,WAAW;AAAA,QACT,WAAW;AAAA,QACX,OAAO;AAAA,QACP,YAAY;AAAA,MACd;AAAA,IACF;AAEA,kBAAiB;AACjB,oBAAqB,oBAAI,IAAI;AAI3B,YAAQ,cAAU,QAAQ,SAAS,KAAK,EAAE,YAAY;AACtD,SAAK,UAAU;AAEf,SAAK,KAAK,QAAQ,MAAM;AACxB,SAAK,OAAO,QAAQ,QAAQ;AAE5B,SAAK,eAAe,QAAQ,SAAS,gBAAgB;AACrD,SAAK,gBAAgB,QAAQ,SAAS,iBAAiB;AACvD,SAAK,iBAAiB,QAAQ,SAAS,kBAAkB;AAAA,EAC3D;AAAA,EACA,MAAM,QAAQ;AACZ,YAAQ,KAAK,qBAAqB,KAAK,QAAQ;AAE/C,SAAK,SAAS,QAAQ,CAAC,YAAY,aAAa,OAAO,CAAC;AACxD,SAAK,WAAW,MAAM;AAAA,EACxB;AAAA,EAEA,UAAgB;AAAA,EAAC;AAAA,EAEjB,MAAM,aAAa;AACjB,WAAO,IAAI,QAAc,CAAC,SAAS,WAAW;AAC5C,YAAM,YAAY;AAClB,UACE,KAAK,cAAc,UACnB,KAAK,UAAU,cAAc,UAAU,MACvC;AACA,cAAM;AAAA,MACR;AACA,WAAK,QAAQ;AAEb,YAAM,MAAM,QAAQ,KAAK,EAAE,IAAI,KAAK,IAAI;AACxC,WAAK,YAAY,IAAI,UAAU,GAAG;AAClC,YAAM,2BAA2B,GAAG;AAEpC,WAAK,UAAU,YAAY,CAAC,YAAY;AACtC,YAAI;AAOJ,YAAI;AAEF,iBAAO,KAAK,MAAM,QAAQ,KAAK,SAAS,CAAC;AACzC,gBAAM,uBAAuB,EAAE,KAAK,CAAC;AAAA,QACvC,SAAS,OAAO;AAEd,eAAK,SAAS,KAAK,SAAS,QAAQ,KAAK,SAAS;AAClD,cAAI;AAEF,mBAAO,KAAK,MAAM,KAAK,MAAM;AAE7B,iBAAK,SAAS;AAAA,UAChB,SAASC,QAAO;AAEd;AAAA,UACF;AAAA,QACF;AAEA,YAAI,cAAc,MAAM;AACtB,cAAI,KAAK,aAAa,MAAM;AAC1B,iBAAK,QAAQ;AACb,kBAAM,qBAAqB;AAC3B,oBAAQ;AAAA,UACV,WAAW,KAAK,aAAa,OAAO;AAClC,iBAAK,QAAQ;AACb,kBAAM,sBAAsB,IAAI;AAChC,mBAAO,yBAAyB,KAAK,OAAO;AAAA,UAC9C;AAAA,QACF,WAAW,WAAW,MAAM;AAC1B,gBAAM,YAAuD;AAC7D,iBAAO,UAAU,MAAM,OAAO;AAC9B,eAAK,OAAO,IAAI;AAAA,QAClB,WAAW,YAAY,MAAM;AAC3B,cACE,OAAO,KAAK,UAAU,YACtB,KAAK,WAAW,QAChB,WAAW,KAAK,QAChB;AACA,iBAAK,YAAY,IAAqB;AAAA,UACxC,OAAO;AACL,iBAAK,OAAO,IAAI;AAAA,UAClB;AAAA,QACF;AAAA,MACF;AAEA,WAAK,UAAU,UAAU,CAAC,UAAU;AAClC,aAAK,QAAQ;AACb,eAAO,KAAK;AAAA,MACd;AAEA,WAAK,UAAU,SAAS,MAAM;AAC5B,cAAM,6CAA6C;AACnD,aAAK,UAAU,KAAK,OAAO;AAC3B,aAAK,QAAQ;AACb,YAAI,KAAK,cAAc;AACrB,qBAAW,MAAM,OAAO,uBAAuB,GAAG,KAAK,YAAY;AAAA,QACrE;AAAA,MACF;AAEA,WAAK,UAAU,UAAU,MAAM;AAC7B,aAAK,QAAQ;AACb,aAAK,YAAY;AACjB,aAAK,QAAQ;AACb,cAAM,mBAAmB;AACzB,eAAO,mBAAmB;AAAA,MAC5B;AAEA,YAAM,4BAA4B;AAAA,IACpC,CAAC;AAAA,EACH;AAAA,EAEQ,UAAU,SAAkB;AAClC,UAAM,OAAO,EAAE,GAAG,QAAQ;AAC1B,UAAM,2BAA2B,EAAE,KAAK,CAAC;AACzC,SAAK,WAAW,KAAK,KAAK,UAAU,IAAI,CAAC;AAAA,EAC3C;AAAA,EACQ,OAAO,MAAW;AACxB,SAAK,UAAU,OAAO,KAAK,EAAE,CAAC,IAAI;AAAA,EACpC;AAAA,EAEQ,YAAY,MAAqB;AACvC,SAAK,OAAO,KAAK,OAAO,KAAK,EAAE,QAAQ,KAAK,OAAO;AACnD,SAAK,OAAO,KAAK,OAAO,KAAK,EAAE,YAAY;AAC3C,UAAM,WAAW,KAAK,OAAO,KAAK,OAAO,KAAK,EAAE;AAChD,UAAM,kBAAkB,EAAE,MAAM,SAAS,CAAC;AAE1C,QAAI,UAAU;AACZ,eAAS,KAAK,OAAO,KAAK;AAAA,IAC5B;AAAA,EACF;AAAA,EAEQ,KACN,QACA,QACA,MACQ;AACR,UAAM,mCAAmC,QAAQ,QAAQ,IAAI;AAC7D,QAAI,KAAK,SAAS,2BAA0B;AAC1C,YAAM,KAAK,KAAK;AAChB,WAAK,MAAM;AACX,YAAM,aAA+D;AAAA,QACnE,GAAG;AAAA,QACH;AAAA,MACF;AAEA,WAAK,WAAW,KAAK,KAAK,UAAU,UAAU,CAAC;AAC/C,WAAK,UAAU,EAAE,IAAI;AACrB,aAAO;AAAA,IACT,OAAO;AACL,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,SACJ,QACA,QACA,MAC6D;AAC7D,UAAM,aAAa,EAAE,KAAK,CAAC;AAE3B,UAAM,KAAK,KAAK,KAAK,QAAQ,QAAQ,IAAI;AAEzC,UAAM,KAAK,eAAe,EAAE;AAC5B,UAAM,OAAO,KAAK,UAAU,EAAE;AAE9B,UAAM,WAAW;AACjB,UAAM,IAAI;AAgBV,WAAO,KAAK,UAAU,EAAE;AAExB,WAAO;AAAA,EACT;AAAA,EAEQ,eAAe,IAAY;AACjC,WAAO,IAAI,QAAc,OAAO,SAAS,WAAW;AAElD,UAAI;AACJ,UAAI,KAAK,gBAAgB;AACvB,kBAAU,WAAW,MAAM;AAEzB,eAAK,SAAS,OAAO,OAAO;AAC5B,iBAAO,iBAAiB;AAAA,QAC1B,GAAG,KAAK,cAAc;AAGtB,aAAK,SAAS,IAAI,OAAO;AAAA,MAC3B;AAEA,eAAS,WAAW,KAAK,YAAY;AACnC,cAAM,MAAM,KAAK,WAAW,QAAQ;AACpC,cAAM,qBAAqB,EAAE;AAG7B,YAAI,KAAK,UAAU,EAAE,MAAM,QAAQ,KAAK,UAAU,EAAE,MAAM,QAAW;AAEnE,gBAAM,YAAY,EAAE,IAAI,KAAK,UAAU,EAAE,CAAC;AAC1C,cAAI,YAAY,QAAW;AACzB,iBAAK,SAAS,OAAO,OAAO;AAAA,UAC9B;AACA,kBAAQ;AACR;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA,EAGA,YACE,WACA,WACc;AACd,WAAO,IAAI,QAAa,OAAO,SAAS,WAAW;AACjD,UAAI;AACJ,UAAI,KAAK,eAAe;AAEtB,kBAAU,WAAW,MAAM;AAEzB,eAAK,SAAS,OAAO,OAAO;AAC5B,iBAAO,qBAAqB;AAAA,QAC9B,GAAG,KAAK,aAAa;AAGrB,aAAK,SAAS,IAAI,OAAO;AAAA,MAC3B;AAEA,eAAS,WAAW,KAAK,YAAY;AACnC,cAAM,MAAM,KAAK,WAAW,QAAQ;AACpC,cAAM,kBAAkB,SAAS;AAGjC,YAAI,cAAc,UAAa,UAAU,KAAK,OAAO,SAAS,EAAE,KAAK;AACnE,cAAI,CAAC,KAAK,OAAO,SAAS,EAAE,WAAW;AAGrC,iBAAK,OAAO,SAAS,EAAE,YAAY;AACnC,kBAAM,iBAAiB,SAAS;AAChC,gBAAI,YAAY,QAAW;AACzB,mBAAK,SAAS,OAAO,OAAO;AAAA,YAC9B;AACA,oBAAQ,KAAK,OAAO,SAAS,EAAE,KAAK;AACpC;AAAA,UACF;AAAA;AAAA,MACJ;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEA,IAAM,qBAAN,cAAiC,WAAW;AAAA,EAI1C,YAAY,KAAa,QAA8B;AACrD,UAAM;AAHR,kBAAS,CAAC;AAIR,YAAQ,cAAU,QAAQ,SAAS,KAAK,EAAE,YAAY;AACtD,SAAK,MAAM,GAAG,GAAG;AAAA,EACnB;AAAA,EAEA,MAAM,SACJ,QACA,QACA,MAC6D;AAC7D,UAAM,KAAK,KAAK;AAChB,UAAM,aAAyD;AAAA,MAC7D,GAAG;AAAA,MACH;AAAA,IACF;AAEA,UAAM,EAAE,WAAW,CAAC;AACpB,UAAM,WAAW,MAAM,MAAM,KAAK,KAAK;AAAA,MACrC,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,MAClB;AAAA,MACA,MAAM,KAAK,UAAU,UAAU;AAAA,IACjC,CAAC;AAED,UAAM,OAAO,MAAM,SAAS,KAAK;AAEjC,UAAM,EAAE,UAAU,KAAK,CAAC;AAExB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAMA,aAA4B;AAC1B,UAAM;AAAA,EACR;AAAA,EACA,QAAc;AAAA,EAAC;AAAA,EACf,UAAgB;AAAA,EAAC;AAAA,EACjB,KACE,QACA,QACA,MACQ;AACR,UAAM;AAAA,EACR;AAAA,EACA,YACE,WACA,WACc;AACd,UAAM;AAAA,EACR;AACF;;;ACnXA,IAAIC,SAAQ,cAAU,KAAK,EAAE,MAAM;AAEnC,IAAM,0BAA0B;AAChC,IAAM,iBAAiB,EAAE,IAAI,aAAa,MAAM,MAAM;AACtD,IAAM,kBAAkB;AAAA,EACtB,cAAc;AAAA,EACd,gBAAgB;AAAA,EAChB,eAAe;AACjB;AAwBO,IAAM,MAAN,MAAU;AAAA,EAWf,YACE,SACA,QAEA,oBAIa,yBACb;AAjBF,kBAA4E;AAAA,MAC1E,aAAa;AAAA,IACf;AACA,gCAAkD;AAClD,6BAAmC;AAsGnC,kBAAS;AAAA,MACP,MAAM;AAAA,MAEN,MAAM,KAAK,QAAc;AACvB,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,QAAQ;AAAA,UAC5D,SAAS;AAAA,UACT,QAAQ;AAAA,UACR;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,MAAM,aAAa;AACjB,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,cAAc;AAAA,UAClE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAAA,MACA,MAAM,WAAW,SAAqB,CAAC,GAAG;AACxC,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,cAAc;AAAA,UAClE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,MAAM,YAAY;AAChB,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,aAAa;AAAA,UACjE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAAA,MACA,MAAM,kBAAkB,QAA2B;AACjD,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,aAAa,SAAuB,CAAC,GAAG;AAC5C,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,gBAAgB;AAAA,UACpE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MAEA,MAAM,iBAAiB,QAA0B;AAC/C,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MAEA,MAAM,sBAAsB,QAA+B;AACzD,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,uBAAuB,QAAgC;AAC3D,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,SAAS,QAAkB;AAC/B,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,YAAY;AAAA,UAChE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,MAAM,SAAS,QAAkB;AAC/B,cAAM,WAAW,MAAM,KAAK,KAAK,YAAY;AAAA,UAC3C;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAAA,MACA,MAAM,SAAS,QAAkB;AAC/B,cAAM,WAAW,MAAM,KAAK,KAAK,YAAY;AAAA,UAC3C;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAEA,YAAI,WAAW,UAAU;AACvB,gBAAM,yBAAyB,SAAS,MAAM;AAAA,QAChD;AAEA,eAAO;AAAA,MACT;AAAA,IACF;AACA,gBAAO;AAAA,MACL,MAAM;AAAA,MAEN,MAAM,KAAK,QAAc;AACvB,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,aAAa;AAAA,UACjE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,MAAM,OAAO;AACX,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,aAAa;AAAA,UACjE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAAA,MACA,MAAM,UAAU;AACd,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,gBAAgB;AAAA,UACpE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAAA,MACA,MAAM,SAAS,QAAsB;AACnC,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,iBAAiB;AAAA,UACrE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,MAAM,2BAA2B,QAAwC;AACvE,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,qBAAqB,QAAkC;AAC3D,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,YAAY;AAChB,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,kBAAkB;AAAA,UACtE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAAA,MACA,MAAM,iBAAiB,SAA+B,CAAC,GAAG;AACxD,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,eAAe,QAA4B;AAC/C,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAYA,MAAM,YAAY;AAChB,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,kBAAkB;AAAA,UACtE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAAA,MACA,MAAM,gBAAgB;AACpB,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR,QAAQ;AAAA,UACV;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,qBAAqB;AACzB,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR,QAAQ;AAAA,UACV;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,iBAAiB,QAA8B;AACnD,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,oBAAoB,QAAiC;AACzD,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,MAAM,QAAmB,mBAA0B;AACvD,YAAI,mBAAmB;AACrB,UAAAA,OAAM,uBAAuB;AAC7B,eAAK,KAAK,UAAU,EAAE,OAAO,iBAAiB,GAAG,MAAM;AACvD,gBAAM,KAAK,KAAK,QAAQ,gBAAgB;AAAA,QAC1C;AACA,eAAO,MAAM,KAAK,KAAK,YAAY,SAAS,UAAU,cAAc;AAAA,UAClE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACA,MAAM,eAAe,QAA4B;AAE/C,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,cAAc,QAA2B;AAC7C,eAAO,MAAM,KAAK,KAAK,YAAY;AAAA,UACjC;AAAA,UACA;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,QAAQ;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AApYE,IAAAA,SAAQ,cAAU,QAAQ,SAAS,KAAK,EAAE,MAAM;AAChD,IAAAA,OAAM,qBAAqB;AAC3B,iBAAa,OAAO;AACpB,SAAK,UAAU;AACf,SAAK,SAAS;AAAA,MACZ,GAAG;AAAA,MACH,GAAI,UAAU,CAAC;AAAA,MACf,SAAS,EAAE,GAAG,iBAAiB,GAAI,QAAQ,WAAW,CAAC,EAAG;AAAA,IAC5D;AACA,SAAK,mBAAmB,IAAI,eAAe,SAAS,MAAM;AAC1D,SAAK,cAAc,KAAK;AAExB,QAAI,mBAAmB;AACrB,WAAK,oBAAoB;AACzB,WAAK,uBAAuB,IAAI,mBAAmB,mBAAmB;AAAA,QACpE,OAAO,QAAQ,SAAS;AAAA,MAC1B,CAAC;AACD,WAAK,cAAc,KAAK;AACxB,WAAK,SAAS,EAAE,aAAa,MAAM,UAAU,KAAK;AAAA,IACpD;AAAA,EAIF;AAAA,EAEA,MAAM,aAAa;AACjB,SAAK,mBAAmB,IAAI,eAAe,KAAK,SAAS,KAAK,MAAM;AAEpE,UAAM,KAAK,iBAAiB,WAAW;AACvC,SAAK,SAAS,EAAE,aAAa,MAAM,UAAU,MAAM;AACnD,SAAK,cAAc,KAAK;AAAA,EAC1B;AAAA,EAEA,MAAM,QAAQ;AACZ,QAAI,KAAK,OAAO,aAAa;AAC3B,WAAK,YAAY,MAAM;AAAA,IACzB;AAAA,EACF;AAAA,EAEA,MAAM,UACJ,EAAE,OAAO,SAAS,GAClB,mBAAyC,aACzC;AACA,QAAI,KAAK,OAAO,eAAe,KAAK,uBAAuB,gBAAgB;AACzE,YAAM,eAAe,MAAM,KAAK,YAAY;AAAA,QAC1C;AAAA,QACA;AAAA,QACA;AAAA,UACE,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,QAAQ,EAAE,MAAM;AAAA,QAClB;AAAA,MACF;AACA,UAAI,YAAY,cAAc;AAC5B,YAAI,aAAa,QAAQ;AACvB,eAAK,YAAY,OAAO,KAAK,EAAE,aAAa;AAE5C,cAAI,oBAAoB,aAAa;AACnC,iBAAK,YAAY,OAAO,KAAK,EAAE,WAAW;AAAA,UAC5C;AAAA,QACF;AACA,eAAO,aAAa;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AACA,YAAQ,KAAK,4CAA4C;AACzD,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,QASJ,OAAW,WAAsD;AACjE,QAAI,KAAK,OAAO,aAAa;AAC3B,aAAO,MAAM,KAAK,YAAY,YAAY,OAAO,SAAS;AAAA,IAC5D;AACA,QAAI,KAAK,uBAAuB,gBAAgB;AAC9C,YAAM;AAAA,IACR;AACA,UAAM;AAAA,EACR;AA+SF;AAEA,SAAS,aAAa,SAAkB;AACtC,MAAI,QAAQ,SAAS,UAAa,QAAQ,KAAK,UAAU,GAAG;AAC1D,UAAM;AAAA,EACR;AACA,MAAI,QAAQ,gBAAgB,UAAa,QAAQ,YAAY,UAAU,GAAG;AACxE,UAAM;AAAA,EACR;AACA,MAAI,QAAQ,OAAO,UAAa,QAAQ,GAAG,UAAU,IAAI;AACvD,UAAM;AAAA,EACR;AACF;;;AC3RO,SAAS,kBACd,MACA,YACA,MAC0B;AAC1B,SAAO;AAAA,IACL;AAAA,MACE,MAAM;AAAA,MACN,UAAU;AAAA,MACV,OAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,UAAU;AAAA,MACV,OAAO;AAAA,IACT;AAAA,IACA,GAAG,eAAe,YAAY,IAAI;AAAA,EACpC;AACF;AAEO,SAAS,eACd,YACA,MAC0B;AAC1B,QAAM,gBAA0C,KAAK;AAAA,IACnD,CAAC,EAAE,MAAM,MAAM,OAAO;AAAA,MACpB;AAAA,MACA,UAAU,OAAO,SAAS,WAAW,MAAM;AAAA;AAAA,MAC3C;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL;AAAA,MACE,MAAM;AAAA,MACN,UAAU;AAAA,MACV,OAAO;AAAA,IACT;AAAA,IACA,GAAG;AAAA,EACL;AACF;","names":["hash","ConnectionState","error","debug"]}
\ No newline at end of file
+{"version":3,"sources":["../src/index.ts","../src/types/types.ts","../src/debug.ts","../src/xswd.ts","../src/utils.ts","../src/types/request.ts"],"sourcesContent":["export * from \"./xswd\";\nexport * from \"./utils\";\nexport * from \"./types/request\";\nexport * from \"./types/response\";\nexport * from \"./types/types\";\n","export type Uint64 = number; // bigint ?\nexport type DVMString = string;\nexport type Hash = string;\nexport type SCCode = string;\nexport type Address = string;\nexport type DataType = \"S\" | \"U\" | \"H\";\n\nexport type Stringkeys = { [key: string]: number | string };\n\nexport type Entity = \"wallet\" | \"daemon\";\n\nexport type Config = {\n  address?: string;\n  port?: number;\n  debug?: boolean;\n  timeout?: {\n    AUTH_TIMEOUT?: number;\n    METHOD_TIMEOUT?: number;\n    BLOCK_TIMEOUT?: number;\n  };\n  secure?: boolean;\n};\n\nexport enum ConnectionState {\n  Initializing = \"initializing\",\n  WaitingAuth = \"waitingAuth\",\n  Accepted = \"accepted\",\n  Refused = \"refused\",\n  Closed = \"closed\",\n}\n\nexport type AppInfo = {\n  //! security threat => token based communication (generated by wallet)\n  id: string; //TODO\n  name: string;\n  description: string;\n  url?: string;\n};\n\nexport type EventType = \"new_topoheight\" | \"new_entry\" | \"new_balance\";\n","export default (DEBUG: boolean) => (label: string) =>\n  DEBUG ? (...data: any) => console.log(label + \":\", ...data) : () => {};\n","import {\n  Echo,\n  GetTransferbyTXID,\n  GetTransfers,\n  MakeIntegratedAddress,\n  QueryKey,\n  SplitIntegratedAddress,\n  SCInvoke,\n  DEROGetBlock,\n  DEROGetBlockHeaderByHash,\n  DEROGetBlockHeaderByTopoHeight,\n  DEROGetBlockTemplate,\n  DEROGetEncryptedBalance,\n  DEROGetGasEstimate,\n  DEROGetRandomAddress,\n  DEROGetSC,\n  DEROGetTransaction,\n  DERONameToAddress,\n  Transfer,\n  GetBalance,\n  GetTrackedAssets,\n  Method,\n  JSONRPCRequestBody,\n} from \"./types/request\";\nimport {\n  AppInfo,\n  Config,\n  ConnectionState,\n  Entity,\n  EventType,\n} from \"./types/types\";\nimport makeDebug from \"./debug\";\nimport {\n  Response,\n  Entry,\n  Balance,\n  Topoheight,\n  Result,\n  AuthResponse,\n  EventResponse,\n} from \"./types/response\";\n\nimport { Chan } from \"@lesomnus/channel\";\nimport { sleep } from \"./utils\";\n\nlet debug = makeDebug(false)(\"xswd\");\n\nconst DEFAULT_CONFIG: Config = {\n  address: \"127.0.0.1\",\n  port: 44326,\n  secure: false,\n  debug: false,\n};\nconst DEFAULT_TIMEOUT = {\n  AUTH_TIMEOUT: undefined,\n  METHOD_TIMEOUT: undefined,\n  BLOCK_TIMEOUT: undefined,\n};\nconst CHECK_INTERVAL = 500;\n\nfunction checkConfig(config: Config) {\n  if (!config.address) {\n    throw \"missing address in fallback config\";\n  }\n}\n\nenum ConnectionType {\n  XSWD = \"xswd\",\n  Fallback = \"fallback\",\n}\n\nexport class Api {\n  connection: { [ct in ConnectionType]: WebSocket | null } = {\n    xswd: null,\n    fallback: null,\n  };\n\n  state: { [ct in ConnectionType]: ConnectionState } = {\n    xswd: ConnectionState.Closed,\n    fallback: ConnectionState.Closed,\n  };\n\n  buffer: string = \"\";\n\n  appInfo: AppInfo;\n  config: {\n    [k in ConnectionType]: k extends ConnectionType.XSWD\n      ? Config\n      : Config | null;\n  };\n\n  response: Chan<Response<Entity, Method<Entity>, Result>> = new Chan(0);\n  subscriptions: {\n    events: {\n      [et in EventType]: {\n        enabled: boolean;\n        waiting: Chan<any>[]; // when using waitfor a channel is added here\n        callback?: (eventValue?: any) => void; // callback defined on subscription\n      };\n    };\n  } = {\n    events: {\n      new_topoheight: {\n        enabled: false,\n        waiting: [],\n        callback: undefined,\n      },\n      new_entry: {\n        enabled: false,\n        waiting: [],\n        callback: undefined,\n      },\n      new_balance: {\n        enabled: false,\n        waiting: [],\n        callback: undefined,\n      },\n    },\n  };\n\n  private nextId: number = 1;\n\n  public get mode(): ConnectionType {\n    return this.state.xswd == ConnectionState.Accepted\n      ? ConnectionType.XSWD\n      : this.state.fallback != ConnectionState.Accepted\n      ? ConnectionType.XSWD\n      : ConnectionType.Fallback;\n  }\n\n  constructor(\n    appInfo: AppInfo,\n    config?: Config,\n    // if xswd fails to connect, at least connect to a public node\n    fallback_config: Config | null = null // no fallback setup by default\n  ) {\n    debug = makeDebug(config?.debug || false)(\"xswd\");\n    debug(\"creating connection\");\n\n    checkAppInfo(appInfo);\n    this.appInfo = appInfo;\n    if (fallback_config) {\n      checkConfig(fallback_config);\n      debug(\"configured fallback:\", fallback_config);\n    }\n\n    this.config = {\n      xswd: {\n        ...DEFAULT_CONFIG,\n        ...(config || {}),\n        timeout: { ...DEFAULT_TIMEOUT, ...(config?.timeout || {}) },\n      },\n      fallback: fallback_config,\n    };\n  }\n\n  // deprecated\n  async initialize() {\n    debug(\"initializing api\");\n    if (this.config.fallback) {\n      await this.initializeFallback().finally(async () => {\n        await this.initializeXSWD();\n      });\n    } else {\n      await this.initializeXSWD();\n    }\n  }\n\n  async initializeFallback() {\n    return new Promise<void>(async (resolve, reject) => {\n      debug(\"initializing fallback\");\n\n      if (this.config.fallback) {\n        this._initializeWebsocket(ConnectionType.Fallback)\n          .then(() => {\n            debug(\"fallback intitialized\");\n            resolve();\n          })\n          .catch((error) => {\n            console.warn(\"failed to initialize fallback:\", error);\n            reject(error);\n          });\n      } else {\n        reject(\"fallback has no config\");\n      }\n    });\n  }\n\n  async initializeXSWD() {\n    return new Promise<void>(async (resolve, reject) => {\n      debug(\"initializing xswd\");\n\n      this._initializeWebsocket(ConnectionType.XSWD)\n        .then(() => {\n          debug(\"xswd initialized\");\n          this.closeFallback();\n\n          resolve();\n        })\n        .catch((error) => {\n          if (this.state.fallback == ConnectionState.Accepted) {\n            console.warn(\"failed to initialize xswd. staying in fallback mode\");\n            console.error(error);\n            reject(error);\n          } else {\n            console.error(\"failed to initialize xswd or fallback:\", error);\n            reject(error);\n          }\n        });\n    });\n  }\n\n  async _initializeWebsocket(connectionType: ConnectionType) {\n    return new Promise<void>((resolve, reject) => {\n      debug(\"initialize \" + connectionType);\n      const websocket = this.connection[connectionType];\n\n      if (websocket !== null && websocket.readyState == WebSocket.OPEN) {\n        throw \"WebSocket is aleady alive\";\n      }\n\n      this.state[connectionType] = ConnectionState.Initializing;\n      const config = this.config[connectionType];\n      if (config != null) {\n        const protocol = config.secure ? \"wss\" : \"ws\";\n        const port = config.port ? `:${config.port}` : \"\";\n        const path = connectionType == ConnectionType.XSWD ? \"xswd\" : \"ws\";\n        const url = `${protocol}://${config.address}${port}/${path}`;\n\n        this.connection[connectionType] = new WebSocket(url);\n        debug(connectionType + \" websocket created for \" + url);\n\n        this._setupHandlers(connectionType, resolve, reject);\n      }\n    });\n  }\n\n  _handleFragmentedData(\n    message: MessageEvent<any>\n  ):\n    | AuthResponse\n    | EventResponse\n    | Response<Entity, Method<Entity>, \"error\">\n    | Response<Entity, Method<Entity>, \"result\">\n    | null {\n    //debug(\"WebSocket:onmessage\", { message });\n    // fragmented messages handling\n    try {\n      // default parsing a single message\n      return JSON.parse(message.data.toString());\n    } catch (error) {\n      // sometimes the result is split in multiple message so we need to buffer\n      this.buffer = this.buffer + message.data.toString();\n      try {\n        // we keep parsing the buffer after updating it to check if the result is complete\n        const data = JSON.parse(this.buffer);\n        // success => we empty the buffer\n        this.buffer = \"\";\n        return data;\n      } catch (error) {\n        // not parsable yet, better luck next message\n        return null;\n      }\n    }\n  }\n\n  async _setupHandlers(\n    connectionType: ConnectionType,\n    resolve: (value: void | PromiseLike<void>) => void,\n    reject: (reason?: any) => void\n  ) {\n    const websocket = this.connection[connectionType];\n    if (websocket) {\n      websocket.onmessage = async (message) => {\n        let data:\n          | AuthResponse\n          | EventResponse\n          | Response<Entity, Method<Entity>, \"error\">\n          | Response<Entity, Method<Entity>, \"result\">\n          | null;\n\n        data = this._handleFragmentedData(message); // some message are not received in a single frame, this function buffers until message is parsable\n        if (data == null) return;\n\n        if (connectionType == ConnectionType.XSWD) {\n          if (\"accepted\" in data) {\n            if (data.accepted === true) {\n              this.state[ConnectionType.XSWD] = ConnectionState.Accepted;\n              debug(\"connection accepted\");\n              resolve();\n            } else if (data.accepted === false) {\n              this.state[ConnectionType.XSWD] = ConnectionState.Refused;\n              debug(\"connection refused\", data);\n              reject(\"connection refused: \" + data.message);\n            }\n          }\n        }\n\n        if (\"error\" in data) {\n          const errorData: Response<Entity, Method<Entity>, \"error\"> = data;\n          await this.response.send(errorData);\n          reject(errorData.error.message);\n        } else if (\"result\" in data) {\n          // event\n          if (\n            connectionType == ConnectionType.XSWD &&\n            typeof data.result == \"object\" &&\n            data.result != null &&\n            \"event\" in data.result\n          ) {\n            const eventData = data as EventResponse;\n            const eventType = eventData.result.event;\n            const eventValue = eventData.result.value;\n\n            if (this.subscriptions.events[eventType].enabled) {\n              const callback = this.subscriptions.events[eventType].callback;\n              if (callback !== undefined) callback(eventValue);\n\n              this.subscriptions.events[eventType].waiting.forEach(\n                (waitingChannel) => {\n                  waitingChannel.send(eventValue);\n                }\n              );\n              return;\n            }\n          }\n          // normal response\n          await this.response.send(data);\n        }\n      };\n\n      websocket.onerror = (error) => {\n        this.state[connectionType] = ConnectionState.Closed;\n        reject(error);\n      };\n\n      websocket.onopen = () => {\n        if (connectionType == ConnectionType.Fallback) {\n          debug(\"fallback websocket connection opened.\");\n          resolve();\n          this.state[connectionType] = ConnectionState.Accepted;\n        } else {\n          debug(\"xswd websocket connection opened, authorizing...\");\n          this.authorize(this.appInfo);\n          this.state.xswd = ConnectionState.WaitingAuth;\n          if (this.config.xswd.timeout?.AUTH_TIMEOUT) {\n            setTimeout(\n              () => reject(\"authorisation timeout\"),\n              this.config.xswd.timeout?.AUTH_TIMEOUT\n            );\n          }\n        }\n      };\n\n      websocket.onclose = (ev) => {\n        this.state[connectionType] = ConnectionState.Closed;\n        this.connection[connectionType] = null;\n        this.onclose(connectionType, ev);\n        debug(connectionType + \" connection closed\");\n        reject(connectionType + \" connection closed\");\n      };\n\n      debug(connectionType + \" websocket handlers are set\");\n    }\n  }\n\n  // callback meant to be set by user\n  onclose(connectionType: ConnectionType, ev: CloseEvent) {}\n\n  async closeXSWD() {\n    if (\n      this.state.xswd == ConnectionState.Accepted ||\n      this.state.xswd == ConnectionState.WaitingAuth\n    ) {\n      debug(\"closing xswd\");\n      this.connection.xswd?.close();\n      this.state.xswd = ConnectionState.Closed;\n    }\n  }\n  async closeFallback() {\n    if (this.state.fallback == ConnectionState.Accepted) {\n      debug(\"closing fallback\");\n      this.connection.fallback?.close();\n\n      this.state.fallback = ConnectionState.Closed;\n    }\n  }\n\n  async close() {\n    this.closeFallback();\n    this.closeXSWD();\n  }\n\n  async Send<E extends Entity, M extends Method<E>>( //! previously sendSync\n    entity: E,\n    method: M,\n    body: Omit<JSONRPCRequestBody<E, M>, \"id\">\n  ) {\n    return new Promise<Response<E, M, \"error\"> | Response<E, M, \"result\">>(\n      async (resolve, reject) => {\n        if (this.mode == ConnectionType.Fallback && entity == \"wallet\") {\n          reject(\"cannot send to wallet in fallback mode.\");\n        }\n\n        debug(\"\\n\\n----------- REQUEST -------\", entity, method, \"\\n\");\n\n        const websocket = this.connection[this.mode];\n\n        if (this.state[this.mode] == ConnectionState.Accepted && websocket) {\n          // assing id to the body\n          const id = this.nextId;\n          this.nextId += 1;\n          const bodyWithId: JSONRPCRequestBody<typeof entity, typeof method> = {\n            ...body,\n            id,\n          };\n\n          /*this.config[this.mode]?.debug &&\n            console.dir({ bodyWithId }, { depth: null });*/\n          debug(\"sending\", bodyWithId);\n\n          // send data\n          websocket.send(JSON.stringify(bodyWithId));\n\n          // listen for the response\n          for (;;) {\n            const response = await this.response.recv();\n            // if ids mismatch\n            if (response.id != String(id)) {\n              // send it back to the channel\n              debug(\"id mismatch: \", response.id, String(id), \", resetting\");\n              await this.response.send(response);\n              await sleep(CHECK_INTERVAL);\n            } else {\n              debug(\"id match\", { response });\n\n              resolve(\n                response as Response<E, M, \"error\"> | Response<E, M, \"result\">\n              );\n              return;\n            }\n          }\n        } else {\n          reject(\"sending without being connected\");\n          return;\n        }\n      }\n    );\n  }\n\n  async subscribe({\n    event,\n    callback,\n  }: {\n    event: EventType;\n    callback?: (value: any) => void;\n  }) {\n    if (\n      this.state.xswd == ConnectionState.Accepted &&\n      this.mode === ConnectionType.XSWD\n    ) {\n      const subscription = await this.Send(\"wallet\", \"Subscribe\", {\n        jsonrpc: \"2.0\",\n        method: \"Subscribe\",\n        params: { event },\n      });\n      if (\"result\" in subscription) {\n        if (subscription.result) {\n          this.subscriptions.events[event].enabled = true;\n          this.subscriptions.events[event].callback = callback;\n        }\n        return subscription.result;\n      }\n      return false;\n    }\n    console.warn(\"cannot subscibe to events in fallback mode\");\n    return false;\n  }\n\n  async waitFor<\n    ET extends EventType,\n    EV = ET extends \"new_balance\"\n      ? Balance\n      : ET extends \"new_topoheight\"\n      ? Topoheight\n      : ET extends \"new_entry\"\n      ? Entry\n      : unknown\n  >(event: ET, predicate?: (eventValue: EV) => boolean): Promise<EV> {\n    if (this.mode == ConnectionType.Fallback) {\n      throw \"cannot wait for event in fallback mode\";\n    }\n\n    if (!this.subscriptions.events[event].enabled) {\n      throw `event ${event} has not been subscribed to`;\n    }\n\n    if (this.state.xswd == ConnectionState.Accepted) {\n      const c = new Chan<any>();\n      this.subscriptions.events[event].waiting.push(c);\n      for (;;) {\n        const value = await c.recv();\n        if (predicate === undefined) {\n          return value;\n        } else if (predicate && predicate(value)) {\n          return value;\n        }\n      }\n    } else {\n      throw \"cannot wait for event if connection is not initialized\";\n    }\n  }\n\n  private authorize(appInfo: AppInfo) {\n    const websocket = this.connection.xswd;\n    if (websocket) {\n      const data = { ...appInfo };\n      debug(\"sending authorisation: \", { data });\n      websocket.send(JSON.stringify(data));\n    }\n  }\n\n  wallet = {\n    _api: this as Api,\n\n    async Echo(params: Echo) {\n      return await this._api.Send(\"wallet\", \"Echo\", {\n        jsonrpc: \"2.0\",\n        method: \"Echo\",\n        params,\n      });\n    },\n    async GetAddress() {\n      return await this._api.Send(\"wallet\", \"GetAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"GetAddress\",\n        params: undefined,\n      });\n    },\n    async GetBalance(params: GetBalance = {}) {\n      return await this._api.Send(\"wallet\", \"GetBalance\", {\n        jsonrpc: \"2.0\",\n        method: \"GetBalance\",\n        params,\n      });\n    },\n    async GetHeight() {\n      return await this._api.Send(\"wallet\", \"GetHeight\", {\n        jsonrpc: \"2.0\",\n        method: \"GetHeight\",\n        params: undefined,\n      });\n    },\n    async GetTransferbyTXID(params: GetTransferbyTXID) {\n      return await this._api.Send(\"wallet\", \"GetTransferbyTXID\", {\n        jsonrpc: \"2.0\",\n        method: \"GetTransferbyTXID\",\n        params,\n      });\n    },\n    async GetTransfers(params: GetTransfers = {}) {\n      return await this._api.Send(\"wallet\", \"GetTransfers\", {\n        jsonrpc: \"2.0\",\n        method: \"GetTransfers\",\n        params,\n      });\n    },\n\n    async GetTrackedAssets(params: GetTrackedAssets) {\n      return await this._api.Send(\"wallet\", \"GetTrackedAssets\", {\n        jsonrpc: \"2.0\",\n        method: \"GetTrackedAssets\",\n        params,\n      });\n    },\n\n    async MakeIntegratedAddress(params: MakeIntegratedAddress) {\n      return await this._api.Send(\"wallet\", \"MakeIntegratedAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"MakeIntegratedAddress\",\n        params,\n      });\n    },\n    async SplitIntegratedAddress(params: SplitIntegratedAddress) {\n      return await this._api.Send(\"wallet\", \"SplitIntegratedAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"SplitIntegratedAddress\",\n        params,\n      });\n    },\n    async QueryKey(params: QueryKey) {\n      return await this._api.Send(\"wallet\", \"QueryKey\", {\n        jsonrpc: \"2.0\",\n        method: \"QueryKey\",\n        params,\n      });\n    },\n    async transfer(params: Transfer) {\n      const response = await this._api.Send(\"wallet\", \"transfer\", {\n        jsonrpc: \"2.0\",\n        method: \"transfer\",\n        params,\n      });\n      return response;\n    },\n    async scinvoke(params: SCInvoke) {\n      const response = await this._api.Send(\"wallet\", \"scinvoke\", {\n        jsonrpc: \"2.0\",\n        method: \"scinvoke\",\n        params,\n      });\n\n      if (\"error\" in response) {\n        throw \"could not scinvoke: \" + response.error.message;\n      }\n\n      return response;\n    },\n  };\n  node = {\n    _api: this as Api,\n\n    async Echo(params: Echo) {\n      return await this._api.Send(\"daemon\", \"DERO.Echo\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.Echo\",\n        params,\n      });\n    },\n    async Ping() {\n      return await this._api.Send(\"daemon\", \"DERO.Ping\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.Ping\",\n        params: undefined,\n      });\n    },\n    async GetInfo() {\n      return await this._api.Send(\"daemon\", \"DERO.GetInfo\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetInfo\",\n        params: undefined,\n      });\n    },\n    async GetBlock(params: DEROGetBlock) {\n      return await this._api.Send(\"daemon\", \"DERO.GetBlock\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlock\",\n        params,\n      });\n    },\n    async GetBlockHeaderByTopoHeight(params: DEROGetBlockHeaderByTopoHeight) {\n      return await this._api.Send(\"daemon\", \"DERO.GetBlockHeaderByTopoHeight\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlockHeaderByTopoHeight\",\n        params,\n      });\n    },\n    async GetBlockHeaderByHash(params: DEROGetBlockHeaderByHash) {\n      return await this._api.Send(\"daemon\", \"DERO.GetBlockHeaderByHash\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlockHeaderByHash\",\n        params,\n      });\n    },\n    async GetTxPool() {\n      return await this._api.Send(\"daemon\", \"DERO.GetTxPool\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetTxPool\",\n        params: undefined,\n      });\n    },\n    async GetRandomAddress(params: DEROGetRandomAddress = {}) {\n      return await this._api.Send(\"daemon\", \"DERO.GetRandomAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetRandomAddress\",\n        params,\n      });\n    },\n    async GetTransaction(params: DEROGetTransaction) {\n      return await this._api.Send(\"daemon\", \"DERO.GetTransaction\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetTransaction\",\n        params,\n      });\n    },\n    /*async SendRawTransaction(params: DEROSendRawTransaction) {\n      return await this._api.sendSync(\n        \"daemon\",\n        \"DERO.SendRawTransaction\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.SendRawTransaction\",\n          params,\n        }\n      );\n    },*/\n    async GetHeight() {\n      return await this._api.Send(\"daemon\", \"DERO.GetHeight\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetHeight\",\n        params: undefined,\n      });\n    },\n    async GetBlockCount() {\n      return await this._api.Send(\"daemon\", \"DERO.GetBlockCount\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlockCount\",\n        params: undefined,\n      });\n    },\n    async GetLastBlockHeader() {\n      return await this._api.Send(\"daemon\", \"DERO.GetLastBlockHeader\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetLastBlockHeader\",\n        params: undefined,\n      });\n    },\n    async GetBlockTemplate(params: DEROGetBlockTemplate) {\n      return await this._api.Send(\"daemon\", \"DERO.GetBlockTemplate\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlockTemplate\",\n        params,\n      });\n    },\n    async GetEncryptedBalance(params: DEROGetEncryptedBalance) {\n      return await this._api.Send(\"daemon\", \"DERO.GetEncryptedBalance\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetEncryptedBalance\",\n        params,\n      });\n    },\n    async GetSC(params: DEROGetSC, waitAfterNewBlock?: true) {\n      if (waitAfterNewBlock) {\n        debug(\"waiting for new block\");\n        this._api.subscribe({ event: \"new_topoheight\" });\n        await this._api.waitFor(\"new_topoheight\");\n      }\n      return await this._api.Send(\"daemon\", \"DERO.GetSC\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetSC\",\n        params,\n      });\n    },\n    async GetGasEstimate(params: DEROGetGasEstimate) {\n      // use gasEstimateSCArgs() to simplify usage\n      return await this._api.Send(\"daemon\", \"DERO.GetGasEstimate\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetGasEstimate\",\n        params,\n      });\n    },\n    async NameToAddress(params: DERONameToAddress) {\n      return await this._api.Send(\"daemon\", \"DERO.NameToAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.NameToAddress\",\n        params,\n      });\n    },\n  };\n}\n\nfunction checkAppInfo(appInfo: AppInfo) {\n  if (appInfo.name !== undefined && appInfo.name.length == 0) {\n    throw \"invalid app name\";\n  }\n  if (appInfo.description !== undefined && appInfo.description.length == 0) {\n    throw \"invalid app description\";\n  }\n  if (appInfo.id !== undefined && appInfo.id.length != 64) {\n    throw \"invalid app id\";\n  }\n}\n","import {\n  ErrorResponse,\n  Response,\n  Result,\n  ResultResponse,\n} from \"./types/response\";\nimport { Entity } from \"./types/types\";\nimport { Method } from \"./types/request\";\nimport \"crypto\";\n\n/*\nasync function hash(message: string) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  const hash = await crypto.subtle.digest(\"SHA-256\", data);\n  return buf2hex(hash);\n}*/\n\nfunction pseudoHash(message: string, length: number = 64) {\n  message = new Array(64 - message.length)\n    .fill(0)\n    .map((_) => message)\n    .join(\"\");\n  console.assert(message.length > 1, \"message length must be > 1\");\n  return [...message]\n    .map((char, i) =>\n      Math.floor(char.charCodeAt(0) * ((7 + i) / (1 + (i % 7)))).toString(16)\n    )\n    .join(\"\")\n    .slice(0, 64);\n}\n\n/*\nfunction buf2hex(buffer: ArrayBuffer) {\n  return [...new Uint8Array(buffer)]\n    .map((x) => x.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n}*/\n\nexport function generateAppId(appName: string): string {\n  return pseudoHash(appName);\n}\n\nexport async function sleep(timems: number) {\n  await new Promise((r) => setTimeout(r, timems));\n}\n\nexport function to<\n  E extends Entity,\n  M extends Method<E>,\n  R extends Result = Result\n>(\n  response: Response<E, M, R>\n): [ErrorResponse | undefined, ResultResponse<E, M> | undefined] {\n  return [\n    \"error\" in response ? (response.error as ErrorResponse) : undefined,\n    \"result\" in response\n      ? (response.result as ResultResponse<E, M>)\n      : undefined,\n  ];\n}\n","import {\n  Address,\n  DVMString,\n  Entity,\n  EventType,\n  Hash,\n  SCCode,\n  Uint64,\n} from \"./types\";\n\nexport type JSONRPCRequest = {\n  method: \"POST\";\n  headers: {\n    \"Content-Type\": \"application/json\";\n  };\n  body: JSONRPCRequestBody<Entity, Method<Entity>>;\n};\n\nexport type JSONRPCRequestBody<E extends Entity, M extends Method<E>> = {\n  jsonrpc: \"2.0\";\n  id: string | number;\n  method: M;\n  params: Params<E, M>;\n};\n\nexport type Method<E extends Entity> = E extends \"daemon\"\n  ?\n      | \"DERO.Echo\"\n      | \"DERO.Ping\"\n      | \"DERO.GetInfo\"\n      | \"DERO.GetBlock\"\n      | \"DERO.GetBlockHeaderByTopoHeight\"\n      | \"DERO.GetBlockHeaderByHash\"\n      | \"DERO.GetTxPool\"\n      | \"DERO.GetRandomAddress\"\n      | \"DERO.GetTransaction\"\n      | \"DERO.SendRawTransaction\"\n      | \"DERO.GetHeight\"\n      | \"DERO.GetBlockCount\"\n      | \"DERO.GetLastBlockHeader\"\n      | \"DERO.GetBlockTemplate\"\n      | \"DERO.GetEncryptedBalance\"\n      | \"DERO.GetSC\"\n      | \"DERO.GetGasEstimate\"\n      | \"DERO.NameToAddress\"\n  :\n      | \"Echo\"\n      | \"GetAddress\"\n      | \"GetBalance\"\n      | \"GetHeight\"\n      | \"GetTransferbyTXID\"\n      | \"GetTransfers\"\n      | \"GetTrackedAssets\"\n      | \"MakeIntegratedAddress\"\n      | \"SplitIntegratedAddress\"\n      | \"QueryKey\"\n      | \"transfer\"\n      | \"scinvoke\"\n      | \"Subscribe\";\n\nexport type Params<\n  E extends Entity,\n  M extends Method<E>\n> = M extends \"DERO.Echo\"\n  ? Echo\n  : M extends \"DERO.Ping\"\n  ? undefined\n  : M extends \"DERO.GetInfo\"\n  ? undefined\n  : M extends \"DERO.GetBlock\"\n  ? DEROGetBlock\n  : M extends \"DERO.GetBlockHeaderByTopoHeight\"\n  ? DEROGetBlockHeaderByTopoHeight\n  : M extends \"DERO.GetBlockHeaderByHash\"\n  ? DEROGetBlockHeaderByHash\n  : M extends \"DERO.GetTxPool\"\n  ? undefined\n  : M extends \"DERO.GetRandomAddress\"\n  ? DEROGetRandomAddress\n  : M extends \"DERO.GetTransaction\"\n  ? DEROGetTransaction\n  : M extends \"DERO.SendRawTransaction\"\n  ? DEROSendRawTransaction\n  : M extends \"DERO.GetHeight\"\n  ? undefined\n  : M extends \"DERO.GetBlockCount\"\n  ? undefined\n  : M extends \"DERO.GetLastBlockHeader\"\n  ? undefined\n  : M extends \"DERO.GetBlockTemplate\"\n  ? DEROGetBlockTemplate\n  : M extends \"DERO.GetEncryptedBalance\"\n  ? DEROGetEncryptedBalance\n  : M extends \"DERO.GetSC\"\n  ? DEROGetSC\n  : M extends \"DERO.GetGasEstimate\"\n  ? DEROGetGasEstimate\n  : M extends \"DERO.NameToAddress\"\n  ? DERONameToAddress\n  : M extends \"GetAddress\"\n  ? undefined\n  : M extends \"GetBalance\"\n  ? GetBalance\n  : M extends \"GetHeight\"\n  ? undefined\n  : M extends \"GetTrackedAssets\"\n  ? GetTrackedAssets\n  : M extends \"GetTransferbyTXID\"\n  ? GetTransferbyTXID\n  : M extends \"GetTransfers\"\n  ? GetTransfers\n  : M extends \"MakeIntegratedAddress\"\n  ? MakeIntegratedAddress\n  : M extends \"SplitIntegratedAddress\"\n  ? SplitIntegratedAddress\n  : M extends \"QueryKey\"\n  ? QueryKey\n  : M extends \"transfer\"\n  ? Transfer\n  : M extends \"scinvoke\"\n  ? SCInvoke\n  : M extends \"Subscribe\"\n  ? { event: EventType }\n  : Echo;\n\nexport type Echo = DVMString[];\n\nexport type WalletTransfer = {\n  amount?: Uint64;\n  burn?: Uint64;\n  destination?: string;\n  scid?: Hash;\n  payload_rpc?: Arguments;\n};\n\ntype ArgumentType = Uint64 | DVMString | Hash;\ntype Argument<AT extends ArgumentType> = {\n  name: DVMString;\n  datatype: AT extends Uint64\n    ? \"U\"\n    : AT extends Hash | DVMString\n    ? \"H\" | \"S\"\n    : unknown;\n  value: AT;\n};\n\ntype Arguments = Argument<ArgumentType>[];\n\nexport type DEROGetBlock = {\n  hash?: Hash;\n  height?: Uint64;\n};\n\nexport type DEROGetBlockHeaderByTopoHeight = {\n  topoheight: Uint64;\n};\n\nexport type DEROGetBlockHeaderByHash = {\n  hash: Hash;\n};\n\nexport type DEROGetRandomAddress = {\n  scid?: Hash;\n};\n\nexport type DEROGetTransaction = {\n  txs_hashes: Hash[];\n  decode_as_json?: Uint64;\n};\n\nexport type DEROSendRawTransaction = {\n  tx_as_hex: DVMString;\n};\n\nexport type DEROGetBlockTemplate = {\n  wallet_address: DVMString;\n  block?: boolean;\n  miner?: DVMString;\n};\n\nexport type DEROGetEncryptedBalance = {\n  address: DVMString;\n  topoheight: Uint64;\n  scid?: Hash;\n  treehash?: Hash;\n};\n\nexport type DEROGetSC = {\n  scid: Hash;\n  code?: boolean;\n  variables?: boolean;\n  topoheight?: Uint64;\n  keysuint64?: Uint64[];\n  keysstring?: DVMString[];\n  keysbytes?: Int8Array[];\n};\n\n// TODO rename transferSCArgs, used in both transfer and gasEstimate\nexport function gasEstimateSCArgs(\n  scid: Hash,\n  entrypoint: string,\n  args: { name: string; value: DVMString | Uint64 }[]\n): Argument<ArgumentType>[] {\n  return [\n    {\n      name: \"SC_ACTION\",\n      datatype: \"U\",\n      value: 0,\n    },\n    {\n      name: \"SC_ID\",\n      datatype: \"H\",\n      value: scid,\n    },\n    ...scinvokeSCArgs(entrypoint, args),\n  ];\n}\n\nexport function scinvokeSCArgs(\n  entrypoint: string,\n  args: { name: string; value: DVMString | Uint64 }[]\n): Argument<ArgumentType>[] {\n  const formattedArgs: Argument<ArgumentType>[] = args.map(\n    ({ name, value }) => ({\n      name,\n      datatype: typeof value == \"number\" ? \"U\" : \"S\", //? bigint?\n      value,\n    })\n  );\n  return [\n    {\n      name: \"entrypoint\",\n      datatype: \"S\",\n      value: entrypoint,\n    },\n    ...formattedArgs,\n  ];\n}\n\nexport type DEROGetGasEstimate = {\n  transfers?: WalletTransfer[];\n  sc?: SCCode;\n  sc_rpc?: Argument<ArgumentType>[];\n  signer?: Address;\n};\n\nexport type DERONameToAddress = {\n  name: DVMString;\n  topoheight: Uint64;\n};\n\nexport type GetBalance = {\n  scid?: Hash;\n};\n\nexport type GetTrackedAssets = {\n  only_positive_balances: boolean;\n  skip_balance_check: boolean;\n};\n\nexport type GetTransferbyTXID = {\n  hash?: Hash;\n  txid?: Hash;\n};\n\nexport type GetTransfers = {\n  scid?: Hash;\n  coinbase?: boolean;\n  in?: boolean;\n  out?: boolean;\n  min_height?: Uint64;\n  max_height?: Uint64;\n  sender?: DVMString;\n  receiver?: DVMString;\n  dstport?: Uint64;\n  srcport?: Uint64;\n};\n\nexport type MakeIntegratedAddress = {\n  address?: DVMString;\n  payload_rpc?: Argument<ArgumentType>;\n};\n\nexport type SplitIntegratedAddress = {\n  integrated_address: DVMString;\n};\n\nexport type QueryKey = { key_type: \"mnemonic\" };\n\nexport type Transfer = {\n  transfers?: WalletTransfer[];\n  sc?: SCCode;\n  sc_rpc?: Arguments;\n  ringsize?: Uint64;\n  scid?: Hash;\n  fees?: Uint64;\n  signer?: Address;\n};\n\nexport type SCInvoke = {\n  scid: Hash;\n  sc_rpc: Arguments;\n\n  sc_dero_deposit?: Uint64;\n  sc_token_deposit?: Uint64;\n  ringsize?: Uint64;\n};\n"],"mappings":"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","names":["ConnectionState","error"]}
\ No newline at end of file
diff --git a/node_modules/dero-xswd-api/dist/index.mjs b/node_modules/dero-xswd-api/dist/index.mjs
index c8fc641..cd0eb66 100644
--- a/node_modules/dero-xswd-api/dist/index.mjs
+++ b/node_modules/dero-xswd-api/dist/index.mjs
@@ -1,19 +1,30 @@
+// src/types/types.ts
+var ConnectionState = /* @__PURE__ */ ((ConnectionState2) => {
+  ConnectionState2["Initializing"] = "initializing";
+  ConnectionState2["WaitingAuth"] = "waitingAuth";
+  ConnectionState2["Accepted"] = "accepted";
+  ConnectionState2["Refused"] = "refused";
+  ConnectionState2["Closed"] = "closed";
+  return ConnectionState2;
+})(ConnectionState || {});
+
 // src/debug.ts
 var debug_default = (DEBUG) => (label) => DEBUG ? (...data) => console.log(label + ":", ...data) : () => {
 };
 
+// src/xswd.ts
+import { Chan } from "@lesomnus/channel";
+
 // src/utils.ts
-async function hash(message) {
-  const encoder = new TextEncoder();
-  const data = encoder.encode(message);
-  const hash2 = await crypto.subtle.digest("SHA-256", data);
-  return buf2hex(hash2);
-}
-function buf2hex(buffer) {
-  return [...new Uint8Array(buffer)].map((x) => x.toString(16).padStart(2, "0")).join("");
+function pseudoHash(message, length = 64) {
+  message = new Array(64 - message.length).fill(0).map((_) => message).join("");
+  console.assert(message.length > 1, "message length must be > 1");
+  return [...message].map(
+    (char, i) => Math.floor(char.charCodeAt(0) * ((7 + i) / (1 + i % 7))).toString(16)
+  ).join("").slice(0, 64);
 }
-async function generateAppId(appName) {
-  return await hash(appName);
+function generateAppId(appName) {
+  return pseudoHash(appName);
 }
 async function sleep(timems) {
   await new Promise((r) => setTimeout(r, timems));
@@ -25,397 +36,143 @@ function to(response) {
   ];
 }
 
-// src/connection.ts
-var debug = debug_default(false)("connection");
-var ConnectionState = /* @__PURE__ */ ((ConnectionState2) => {
-  ConnectionState2["Initializing"] = "initializing";
-  ConnectionState2["WaitingAuth"] = "waitingAuth";
-  ConnectionState2["Accepted"] = "accepted";
-  ConnectionState2["Refused"] = "refused";
-  ConnectionState2["Closed"] = "closed";
-  return ConnectionState2;
-})(ConnectionState || {});
-var Connection = class {
-  constructor() {
-    this.id = 1;
-    this.AUTH_TIMEOUT = null;
-    this.METHOD_TIMEOUT = null;
-    this.BLOCK_TIMEOUT = null;
-    this.INTERVAL = 100;
-  }
-};
-var XSWDConnection = class extends Connection {
-  constructor(appInfo, config) {
-    super();
-    this.state = "initializing" /* Initializing */;
-    this.responses = {};
-    this.events = {
-      new_topoheight: {
-        processed: true,
-        value: 0,
-        subscribed: false
-      },
-      new_balance: {
-        processed: true,
-        value: 0,
-        subscribed: false
-      },
-      new_entry: {
-        processed: true,
-        value: "",
-        subscribed: false
-      }
-    };
-    this.buffer = "";
-    this.timeouts = /* @__PURE__ */ new Set();
-    debug = debug_default(config?.debug || false)("connection");
-    this.appInfo = appInfo;
-    this.ip = config?.ip || "localhost";
-    this.port = config?.port || 44326;
-    this.AUTH_TIMEOUT = config?.timeout?.AUTH_TIMEOUT || null;
-    this.BLOCK_TIMEOUT = config?.timeout?.BLOCK_TIMEOUT || null;
-    this.METHOD_TIMEOUT = config?.timeout?.METHOD_TIMEOUT || null;
-  }
-  async close() {
-    console.warn("closing websocket", this.timeouts);
-    this.timeouts.forEach((timeout) => clearTimeout(timeout));
-    this.websocket?.close();
-  }
-  onclose() {
-  }
-  async initialize() {
-    return new Promise((resolve, reject) => {
-      debug("initialize");
-      if (this.websocket !== void 0 && this.websocket.readyState == WebSocket.OPEN) {
-        throw "WebSocket is aleady alive";
-      }
-      this.state = "initializing" /* Initializing */;
-      const url = `ws://${this.ip}:${this.port}/xswd`;
-      this.websocket = new WebSocket(url);
-      debug("websocket created for " + url);
-      this.websocket.onmessage = (message) => {
-        let data;
-        try {
-          data = JSON.parse(message.data.toString());
-          debug("WebSocket:onmessage", { data });
-        } catch (error) {
-          this.buffer = this.buffer + message.data.toString();
-          try {
-            data = JSON.parse(this.buffer);
-            this.buffer = "";
-          } catch (error2) {
-            return;
-          }
-        }
-        if ("accepted" in data) {
-          if (data.accepted === true) {
-            this.state = "accepted" /* Accepted */;
-            debug("connection accepted");
-            resolve();
-          } else if (data.accepted === false) {
-            this.state = "refused" /* Refused */;
-            debug("connection refused", data);
-            reject("connection refused: " + data.message);
-          }
-        } else if ("error" in data) {
-          const errorData = data;
-          reject(errorData.error.message);
-          this.handle(data);
-        } else if ("result" in data) {
-          if (typeof data.result == "object" && data.result !== null && "event" in data.result) {
-            this.handleEvent(data);
-          } else {
-            this.handle(data);
-          }
-        }
-      };
-      this.websocket.onerror = (error) => {
-        this.state = "closed" /* Closed */;
-        reject(error);
-      };
-      this.websocket.onopen = () => {
-        debug("websocket connection opened, authorizing...");
-        this.authorize(this.appInfo);
-        this.state = "waitingAuth" /* WaitingAuth */;
-        if (this.AUTH_TIMEOUT) {
-          setTimeout(() => reject("authorisation timeout"), this.AUTH_TIMEOUT);
-        }
-      };
-      this.websocket.onclose = () => {
-        this.state = "initializing" /* Initializing */;
-        this.websocket = void 0;
-        this.onclose();
-        debug("connection closed");
-        reject("connection closed");
-      };
-      debug("websocket handlers are set");
-    });
-  }
-  authorize(appInfo) {
-    const data = { ...appInfo };
-    debug("sending authorisation: ", { data });
-    this.websocket?.send(JSON.stringify(data));
-  }
-  handle(data) {
-    this.responses[Number(data.id)] = data;
-  }
-  handleEvent(data) {
-    this.events[data.result.event].value = data.result.value;
-    this.events[data.result.event].processed = false;
-    const callback = this.events[data.result.event].callback;
-    debug("Handling event", { data, callback });
-    if (callback) {
-      callback(data.result.value);
-    }
-  }
-  send(entity, method, body) {
-    debug("\n\n----------- REQUEST -------", entity, method, "\n");
-    if (this.state == "accepted" /* Accepted */) {
-      const id = this.id;
-      this.id += 1;
-      const bodyWithId = {
-        ...body,
-        id
-      };
-      this.websocket?.send(JSON.stringify(bodyWithId));
-      this.responses[id] = null;
-      return id;
-    } else {
-      throw "sending without being connected";
-    }
-  }
-  async sendSync(entity, method, body) {
-    debug("sendSync:", { body });
-    const id = this.send(entity, method, body);
-    await this._checkResponse(id);
-    const data = this.responses[id];
-    debug("Response:");
-    debug(data);
-    delete this.responses[id];
-    return data;
-  }
-  _checkResponse(id) {
-    return new Promise(async (resolve, reject) => {
-      let timeout;
-      if (this.METHOD_TIMEOUT) {
-        timeout = setTimeout(() => {
-          this.timeouts.delete(timeout);
-          reject("request timeout");
-        }, this.METHOD_TIMEOUT);
-        this.timeouts.add(timeout);
-      }
-      for (let attempts = 1; ; attempts++) {
-        await sleep(this.INTERVAL * attempts);
-        debug("checking response", id);
-        if (this.responses[id] !== null && this.responses[id] !== void 0) {
-          debug(`response ${id}`, this.responses[id]);
-          if (timeout !== void 0) {
-            this.timeouts.delete(timeout);
-          }
-          resolve();
-          break;
-        }
-      }
-    });
-  }
-  // TODO Typing
-  _checkEvent(eventType, predicate) {
-    return new Promise(async (resolve, reject) => {
-      let timeout;
-      if (this.BLOCK_TIMEOUT) {
-        timeout = setTimeout(() => {
-          this.timeouts.delete(timeout);
-          reject("event check timeout");
-        }, this.BLOCK_TIMEOUT);
-        this.timeouts.add(timeout);
-      }
-      for (let attempts = 1; ; attempts++) {
-        await sleep(this.INTERVAL * attempts);
-        debug("checking event", eventType);
-        if (predicate === void 0 || predicate(this.events[eventType].value)) {
-          if (!this.events[eventType].processed) {
-            this.events[eventType].processed = true;
-            debug("checked event", eventType);
-            if (timeout !== void 0) {
-              this.timeouts.delete(timeout);
-            }
-            resolve(this.events[eventType].value);
-            break;
-          }
-        }
-      }
-    });
-  }
-};
-var FallbackConnection = class extends Connection {
-  constructor(url, config) {
-    super();
-    this.events = {};
-    debug = debug_default(config?.debug || false)("connection");
-    this.url = `${url}/json_rpc`;
-  }
-  async sendSync(entity, method, body) {
-    const id = this.id++;
-    const bodyWithId = {
-      ...body,
-      id
-    };
-    debug({ bodyWithId });
-    const response = await fetch(this.url, {
-      method: "POST",
-      headers: {
-        "Content-Type": "application/json"
-      },
-      body: JSON.stringify(bodyWithId)
-    });
-    const json = await response.json();
-    debug({ response: json });
-    return json;
-  }
-  //
-  // Inactive methods
-  //
-  initialize() {
-    throw "Connection.initialize() shall not be used in fallback mode";
-  }
-  close() {
-  }
-  onclose() {
-  }
-  send(entity, method, body) {
-    throw "Connection.send() shall not be used in fallback mode";
-  }
-  _checkEvent(eventType, predicate) {
-    throw "Connection._checkEvent() shall not be used in fallback mode";
-  }
-};
-
 // src/xswd.ts
-var debug2 = debug_default(false)("xswd");
-var DEFAULT_FALLBACK_CONFIG = "dero-api.mysrv.cloud:443";
-var DEFAULT_CONFIG = { ip: "localhost", port: 44326 };
+var debug = debug_default(false)("xswd");
+var DEFAULT_CONFIG = {
+  address: "127.0.0.1",
+  port: 44326,
+  secure: false,
+  debug: false
+};
 var DEFAULT_TIMEOUT = {
   AUTH_TIMEOUT: void 0,
   METHOD_TIMEOUT: void 0,
   BLOCK_TIMEOUT: void 0
 };
+var CHECK_INTERVAL = 500;
+function checkConfig(config) {
+  if (!config.address) {
+    throw "missing address in fallback config";
+  }
+}
 var Api = class {
-  constructor(appInfo, config, fallback_http_rpc = DEFAULT_FALLBACK_CONFIG) {
-    this.status = {
-      initialized: false
+  constructor(appInfo, config, fallback_config = null) {
+    this.connection = {
+      xswd: null,
+      fallback: null
+    };
+    this.state = {
+      xswd: "closed" /* Closed */,
+      fallback: "closed" /* Closed */
+    };
+    this.buffer = "";
+    this.response = new Chan(0);
+    this.subscriptions = {
+      events: {
+        new_topoheight: {
+          enabled: false,
+          waiting: [],
+          callback: void 0
+        },
+        new_entry: {
+          enabled: false,
+          waiting: [],
+          callback: void 0
+        },
+        new_balance: {
+          enabled: false,
+          waiting: [],
+          callback: void 0
+        }
+      }
     };
-    this._fallback_connection = null;
-    this.fallback_http_rpc = null;
+    this.nextId = 1;
     this.wallet = {
       _api: this,
       async Echo(params) {
-        return await this._api._connection.sendSync("wallet", "Echo", {
+        return await this._api.Send("wallet", "Echo", {
           jsonrpc: "2.0",
           method: "Echo",
           params
         });
       },
       async GetAddress() {
-        return await this._api._connection.sendSync("wallet", "GetAddress", {
+        return await this._api.Send("wallet", "GetAddress", {
           jsonrpc: "2.0",
           method: "GetAddress",
           params: void 0
         });
       },
       async GetBalance(params = {}) {
-        return await this._api._connection.sendSync("wallet", "GetBalance", {
+        return await this._api.Send("wallet", "GetBalance", {
           jsonrpc: "2.0",
           method: "GetBalance",
           params
         });
       },
       async GetHeight() {
-        return await this._api._connection.sendSync("wallet", "GetHeight", {
+        return await this._api.Send("wallet", "GetHeight", {
           jsonrpc: "2.0",
           method: "GetHeight",
           params: void 0
         });
       },
       async GetTransferbyTXID(params) {
-        return await this._api._connection.sendSync(
-          "wallet",
-          "GetTransferbyTXID",
-          {
-            jsonrpc: "2.0",
-            method: "GetTransferbyTXID",
-            params
-          }
-        );
+        return await this._api.Send("wallet", "GetTransferbyTXID", {
+          jsonrpc: "2.0",
+          method: "GetTransferbyTXID",
+          params
+        });
       },
       async GetTransfers(params = {}) {
-        return await this._api._connection.sendSync("wallet", "GetTransfers", {
+        return await this._api.Send("wallet", "GetTransfers", {
           jsonrpc: "2.0",
           method: "GetTransfers",
           params
         });
       },
       async GetTrackedAssets(params) {
-        return await this._api._connection.sendSync(
-          "wallet",
-          "GetTrackedAssets",
-          {
-            jsonrpc: "2.0",
-            method: "GetTrackedAssets",
-            params
-          }
-        );
+        return await this._api.Send("wallet", "GetTrackedAssets", {
+          jsonrpc: "2.0",
+          method: "GetTrackedAssets",
+          params
+        });
       },
       async MakeIntegratedAddress(params) {
-        return await this._api._connection.sendSync(
-          "wallet",
-          "MakeIntegratedAddress",
-          {
-            jsonrpc: "2.0",
-            method: "MakeIntegratedAddress",
-            params
-          }
-        );
+        return await this._api.Send("wallet", "MakeIntegratedAddress", {
+          jsonrpc: "2.0",
+          method: "MakeIntegratedAddress",
+          params
+        });
       },
       async SplitIntegratedAddress(params) {
-        return await this._api._connection.sendSync(
-          "wallet",
-          "SplitIntegratedAddress",
-          {
-            jsonrpc: "2.0",
-            method: "SplitIntegratedAddress",
-            params
-          }
-        );
+        return await this._api.Send("wallet", "SplitIntegratedAddress", {
+          jsonrpc: "2.0",
+          method: "SplitIntegratedAddress",
+          params
+        });
       },
       async QueryKey(params) {
-        return await this._api._connection.sendSync("wallet", "QueryKey", {
+        return await this._api.Send("wallet", "QueryKey", {
           jsonrpc: "2.0",
           method: "QueryKey",
           params
         });
       },
       async transfer(params) {
-        const response = await this._api._connection.sendSync(
-          "wallet",
-          "transfer",
-          {
-            jsonrpc: "2.0",
-            method: "transfer",
-            params
-          }
-        );
+        const response = await this._api.Send("wallet", "transfer", {
+          jsonrpc: "2.0",
+          method: "transfer",
+          params
+        });
         return response;
       },
       async scinvoke(params) {
-        const response = await this._api._connection.sendSync(
-          "wallet",
-          "scinvoke",
-          {
-            jsonrpc: "2.0",
-            method: "scinvoke",
-            params
-          }
-        );
+        const response = await this._api.Send("wallet", "scinvoke", {
+          jsonrpc: "2.0",
+          method: "scinvoke",
+          params
+        });
         if ("error" in response) {
           throw "could not scinvoke: " + response.error.message;
         }
@@ -425,86 +182,70 @@ var Api = class {
     this.node = {
       _api: this,
       async Echo(params) {
-        return await this._api._connection.sendSync("daemon", "DERO.Echo", {
+        return await this._api.Send("daemon", "DERO.Echo", {
           jsonrpc: "2.0",
           method: "DERO.Echo",
           params
         });
       },
       async Ping() {
-        return await this._api._connection.sendSync("daemon", "DERO.Ping", {
+        return await this._api.Send("daemon", "DERO.Ping", {
           jsonrpc: "2.0",
           method: "DERO.Ping",
           params: void 0
         });
       },
       async GetInfo() {
-        return await this._api._connection.sendSync("daemon", "DERO.GetInfo", {
+        return await this._api.Send("daemon", "DERO.GetInfo", {
           jsonrpc: "2.0",
           method: "DERO.GetInfo",
           params: void 0
         });
       },
       async GetBlock(params) {
-        return await this._api._connection.sendSync("daemon", "DERO.GetBlock", {
+        return await this._api.Send("daemon", "DERO.GetBlock", {
           jsonrpc: "2.0",
           method: "DERO.GetBlock",
           params
         });
       },
       async GetBlockHeaderByTopoHeight(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetBlockHeaderByTopoHeight",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetBlockHeaderByTopoHeight",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetBlockHeaderByTopoHeight", {
+          jsonrpc: "2.0",
+          method: "DERO.GetBlockHeaderByTopoHeight",
+          params
+        });
       },
       async GetBlockHeaderByHash(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetBlockHeaderByHash",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetBlockHeaderByHash",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetBlockHeaderByHash", {
+          jsonrpc: "2.0",
+          method: "DERO.GetBlockHeaderByHash",
+          params
+        });
       },
       async GetTxPool() {
-        return await this._api._connection.sendSync("daemon", "DERO.GetTxPool", {
+        return await this._api.Send("daemon", "DERO.GetTxPool", {
           jsonrpc: "2.0",
           method: "DERO.GetTxPool",
           params: void 0
         });
       },
       async GetRandomAddress(params = {}) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetRandomAddress",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetRandomAddress",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetRandomAddress", {
+          jsonrpc: "2.0",
+          method: "DERO.GetRandomAddress",
+          params
+        });
       },
       async GetTransaction(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetTransaction",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetTransaction",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetTransaction", {
+          jsonrpc: "2.0",
+          method: "DERO.GetTransaction",
+          params
+        });
       },
       /*async SendRawTransaction(params: DEROSendRawTransaction) {
-        return await this._api._connection.sendSync(
+        return await this._api.sendSync(
           "daemon",
           "DERO.SendRawTransaction",
           {
@@ -515,139 +256,316 @@ var Api = class {
         );
       },*/
       async GetHeight() {
-        return await this._api._connection.sendSync("daemon", "DERO.GetHeight", {
+        return await this._api.Send("daemon", "DERO.GetHeight", {
           jsonrpc: "2.0",
           method: "DERO.GetHeight",
           params: void 0
         });
       },
       async GetBlockCount() {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetBlockCount",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetBlockCount",
-            params: void 0
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetBlockCount", {
+          jsonrpc: "2.0",
+          method: "DERO.GetBlockCount",
+          params: void 0
+        });
       },
       async GetLastBlockHeader() {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetLastBlockHeader",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetLastBlockHeader",
-            params: void 0
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetLastBlockHeader", {
+          jsonrpc: "2.0",
+          method: "DERO.GetLastBlockHeader",
+          params: void 0
+        });
       },
       async GetBlockTemplate(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetBlockTemplate",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetBlockTemplate",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetBlockTemplate", {
+          jsonrpc: "2.0",
+          method: "DERO.GetBlockTemplate",
+          params
+        });
       },
       async GetEncryptedBalance(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetEncryptedBalance",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetEncryptedBalance",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetEncryptedBalance", {
+          jsonrpc: "2.0",
+          method: "DERO.GetEncryptedBalance",
+          params
+        });
       },
       async GetSC(params, waitAfterNewBlock) {
         if (waitAfterNewBlock) {
-          debug2("waiting for new block");
-          this._api.subscribe({ event: "new_topoheight" }, "auto");
+          debug("waiting for new block");
+          this._api.subscribe({ event: "new_topoheight" });
           await this._api.waitFor("new_topoheight");
         }
-        return await this._api._connection.sendSync("daemon", "DERO.GetSC", {
+        return await this._api.Send("daemon", "DERO.GetSC", {
           jsonrpc: "2.0",
           method: "DERO.GetSC",
           params
         });
       },
       async GetGasEstimate(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.GetGasEstimate",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.GetGasEstimate",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.GetGasEstimate", {
+          jsonrpc: "2.0",
+          method: "DERO.GetGasEstimate",
+          params
+        });
       },
       async NameToAddress(params) {
-        return await this._api._connection.sendSync(
-          "daemon",
-          "DERO.NameToAddress",
-          {
-            jsonrpc: "2.0",
-            method: "DERO.NameToAddress",
-            params
-          }
-        );
+        return await this._api.Send("daemon", "DERO.NameToAddress", {
+          jsonrpc: "2.0",
+          method: "DERO.NameToAddress",
+          params
+        });
       }
     };
-    debug2 = debug_default(config?.debug || false)("xswd");
-    debug2("creating connection");
+    debug = debug_default(config?.debug || false)("xswd");
+    debug("creating connection");
     checkAppInfo(appInfo);
     this.appInfo = appInfo;
+    if (fallback_config) {
+      checkConfig(fallback_config);
+      debug("configured fallback:", fallback_config);
+    }
     this.config = {
-      ...DEFAULT_CONFIG,
-      ...config || {},
-      timeout: { ...DEFAULT_TIMEOUT, ...config?.timeout || {} }
+      xswd: {
+        ...DEFAULT_CONFIG,
+        ...config || {},
+        timeout: { ...DEFAULT_TIMEOUT, ...config?.timeout || {} }
+      },
+      fallback: fallback_config
     };
-    this._xswd_connection = new XSWDConnection(appInfo, config);
-    this._connection = this._xswd_connection;
-    if (fallback_http_rpc) {
-      this.fallback_http_rpc = fallback_http_rpc;
-      this._fallback_connection = new FallbackConnection(fallback_http_rpc, {
-        debug: config?.debug || false
+  }
+  get mode() {
+    return this.state.xswd == "accepted" /* Accepted */ ? "xswd" /* XSWD */ : this.state.fallback != "accepted" /* Accepted */ ? "xswd" /* XSWD */ : "fallback" /* Fallback */;
+  }
+  // deprecated
+  async initialize() {
+    debug("initializing api");
+    if (this.config.fallback) {
+      await this.initializeFallback().finally(async () => {
+        await this.initializeXSWD();
       });
-      this._connection = this._fallback_connection;
-      this.status = { initialized: true, fallback: true };
+    } else {
+      await this.initializeXSWD();
     }
   }
-  async initialize() {
-    this._xswd_connection = new XSWDConnection(this.appInfo, this.config);
-    await this._xswd_connection.initialize();
-    this.status = { initialized: true, fallback: false };
-    this._connection = this._xswd_connection;
+  async initializeFallback() {
+    return new Promise(async (resolve, reject) => {
+      debug("initializing fallback");
+      if (this.config.fallback) {
+        this._initializeWebsocket("fallback" /* Fallback */).then(() => {
+          debug("fallback intitialized");
+          resolve();
+        }).catch((error) => {
+          console.warn("failed to initialize fallback:", error);
+          reject(error);
+        });
+      } else {
+        reject("fallback has no config");
+      }
+    });
   }
-  async close() {
-    if (this.status.initialized) {
-      this._connection.close();
+  async initializeXSWD() {
+    return new Promise(async (resolve, reject) => {
+      debug("initializing xswd");
+      this._initializeWebsocket("xswd" /* XSWD */).then(() => {
+        debug("xswd initialized");
+        this.closeFallback();
+        resolve();
+      }).catch((error) => {
+        if (this.state.fallback == "accepted" /* Accepted */) {
+          console.warn("failed to initialize xswd. staying in fallback mode");
+          console.error(error);
+          reject(error);
+        } else {
+          console.error("failed to initialize xswd or fallback:", error);
+          reject(error);
+        }
+      });
+    });
+  }
+  async _initializeWebsocket(connectionType) {
+    return new Promise((resolve, reject) => {
+      debug("initialize " + connectionType);
+      const websocket = this.connection[connectionType];
+      if (websocket !== null && websocket.readyState == WebSocket.OPEN) {
+        throw "WebSocket is aleady alive";
+      }
+      this.state[connectionType] = "initializing" /* Initializing */;
+      const config = this.config[connectionType];
+      if (config != null) {
+        const protocol = config.secure ? "wss" : "ws";
+        const port = config.port ? `:${config.port}` : "";
+        const path = connectionType == "xswd" /* XSWD */ ? "xswd" : "ws";
+        const url = `${protocol}://${config.address}${port}/${path}`;
+        this.connection[connectionType] = new WebSocket(url);
+        debug(connectionType + " websocket created for " + url);
+        this._setupHandlers(connectionType, resolve, reject);
+      }
+    });
+  }
+  _handleFragmentedData(message) {
+    try {
+      return JSON.parse(message.data.toString());
+    } catch (error) {
+      this.buffer = this.buffer + message.data.toString();
+      try {
+        const data = JSON.parse(this.buffer);
+        this.buffer = "";
+        return data;
+      } catch (error2) {
+        return null;
+      }
     }
   }
-  async subscribe({ event, callback }, subscriptionType = "permanent") {
-    if (this.status.initialized && this._connection instanceof XSWDConnection) {
-      const subscription = await this._connection.sendSync(
-        "wallet",
-        "Subscribe",
-        {
-          jsonrpc: "2.0",
-          method: "Subscribe",
-          params: { event }
+  async _setupHandlers(connectionType, resolve, reject) {
+    const websocket = this.connection[connectionType];
+    if (websocket) {
+      websocket.onmessage = async (message) => {
+        let data;
+        data = this._handleFragmentedData(message);
+        if (data == null)
+          return;
+        if (connectionType == "xswd" /* XSWD */) {
+          if ("accepted" in data) {
+            if (data.accepted === true) {
+              this.state["xswd" /* XSWD */] = "accepted" /* Accepted */;
+              debug("connection accepted");
+              resolve();
+            } else if (data.accepted === false) {
+              this.state["xswd" /* XSWD */] = "refused" /* Refused */;
+              debug("connection refused", data);
+              reject("connection refused: " + data.message);
+            }
+          }
+        }
+        if ("error" in data) {
+          const errorData = data;
+          await this.response.send(errorData);
+          reject(errorData.error.message);
+        } else if ("result" in data) {
+          if (connectionType == "xswd" /* XSWD */ && typeof data.result == "object" && data.result != null && "event" in data.result) {
+            const eventData = data;
+            const eventType = eventData.result.event;
+            const eventValue = eventData.result.value;
+            if (this.subscriptions.events[eventType].enabled) {
+              const callback = this.subscriptions.events[eventType].callback;
+              if (callback !== void 0)
+                callback(eventValue);
+              this.subscriptions.events[eventType].waiting.forEach(
+                (waitingChannel) => {
+                  waitingChannel.send(eventValue);
+                }
+              );
+              return;
+            }
+          }
+          await this.response.send(data);
+        }
+      };
+      websocket.onerror = (error) => {
+        this.state[connectionType] = "closed" /* Closed */;
+        reject(error);
+      };
+      websocket.onopen = () => {
+        if (connectionType == "fallback" /* Fallback */) {
+          debug("fallback websocket connection opened.");
+          resolve();
+          this.state[connectionType] = "accepted" /* Accepted */;
+        } else {
+          debug("xswd websocket connection opened, authorizing...");
+          this.authorize(this.appInfo);
+          this.state.xswd = "waitingAuth" /* WaitingAuth */;
+          if (this.config.xswd.timeout?.AUTH_TIMEOUT) {
+            setTimeout(
+              () => reject("authorisation timeout"),
+              this.config.xswd.timeout?.AUTH_TIMEOUT
+            );
+          }
+        }
+      };
+      websocket.onclose = (ev) => {
+        this.state[connectionType] = "closed" /* Closed */;
+        this.connection[connectionType] = null;
+        this.onclose(connectionType, ev);
+        debug(connectionType + " connection closed");
+        reject(connectionType + " connection closed");
+      };
+      debug(connectionType + " websocket handlers are set");
+    }
+  }
+  // callback meant to be set by user
+  onclose(connectionType, ev) {
+  }
+  async closeXSWD() {
+    if (this.state.xswd == "accepted" /* Accepted */ || this.state.xswd == "waitingAuth" /* WaitingAuth */) {
+      debug("closing xswd");
+      this.connection.xswd?.close();
+      this.state.xswd = "closed" /* Closed */;
+    }
+  }
+  async closeFallback() {
+    if (this.state.fallback == "accepted" /* Accepted */) {
+      debug("closing fallback");
+      this.connection.fallback?.close();
+      this.state.fallback = "closed" /* Closed */;
+    }
+  }
+  async close() {
+    this.closeFallback();
+    this.closeXSWD();
+  }
+  async Send(entity, method, body) {
+    return new Promise(
+      async (resolve, reject) => {
+        if (this.mode == "fallback" /* Fallback */ && entity == "wallet") {
+          reject("cannot send to wallet in fallback mode.");
         }
-      );
+        debug("\n\n----------- REQUEST -------", entity, method, "\n");
+        const websocket = this.connection[this.mode];
+        if (this.state[this.mode] == "accepted" /* Accepted */ && websocket) {
+          const id = this.nextId;
+          this.nextId += 1;
+          const bodyWithId = {
+            ...body,
+            id
+          };
+          debug("sending", bodyWithId);
+          websocket.send(JSON.stringify(bodyWithId));
+          for (; ; ) {
+            const response = await this.response.recv();
+            if (response.id != String(id)) {
+              debug("id mismatch: ", response.id, String(id), ", resetting");
+              await this.response.send(response);
+              await sleep(CHECK_INTERVAL);
+            } else {
+              debug("id match", { response });
+              resolve(
+                response
+              );
+              return;
+            }
+          }
+        } else {
+          reject("sending without being connected");
+          return;
+        }
+      }
+    );
+  }
+  async subscribe({
+    event,
+    callback
+  }) {
+    if (this.state.xswd == "accepted" /* Accepted */ && this.mode === "xswd" /* XSWD */) {
+      const subscription = await this.Send("wallet", "Subscribe", {
+        jsonrpc: "2.0",
+        method: "Subscribe",
+        params: { event }
+      });
       if ("result" in subscription) {
         if (subscription.result) {
-          this._connection.events[event].subscribed = subscriptionType;
-          if (subscriptionType == "permanent") {
-            this._connection.events[event].callback = callback;
-          }
+          this.subscriptions.events[event].enabled = true;
+          this.subscriptions.events[event].callback = callback;
         }
         return subscription.result;
       }
@@ -657,13 +575,34 @@ var Api = class {
     return false;
   }
   async waitFor(event, predicate) {
-    if (this.status.initialized) {
-      return await this._connection._checkEvent(event, predicate);
+    if (this.mode == "fallback" /* Fallback */) {
+      throw "cannot wait for event in fallback mode";
+    }
+    if (!this.subscriptions.events[event].enabled) {
+      throw `event ${event} has not been subscribed to`;
     }
-    if (this._connection instanceof XSWDConnection) {
+    if (this.state.xswd == "accepted" /* Accepted */) {
+      const c = new Chan();
+      this.subscriptions.events[event].waiting.push(c);
+      for (; ; ) {
+        const value = await c.recv();
+        if (predicate === void 0) {
+          return value;
+        } else if (predicate && predicate(value)) {
+          return value;
+        }
+      }
+    } else {
       throw "cannot wait for event if connection is not initialized";
     }
-    throw "cannot wait for event in fallback mode";
+  }
+  authorize(appInfo) {
+    const websocket = this.connection.xswd;
+    if (websocket) {
+      const data = { ...appInfo };
+      debug("sending authorisation: ", { data });
+      websocket.send(JSON.stringify(data));
+    }
   }
 };
 function checkAppInfo(appInfo) {
@@ -714,10 +653,7 @@ function scinvokeSCArgs(entrypoint, args) {
 }
 export {
   Api,
-  Connection,
   ConnectionState,
-  FallbackConnection,
-  XSWDConnection,
   gasEstimateSCArgs,
   generateAppId,
   scinvokeSCArgs,
diff --git a/node_modules/dero-xswd-api/dist/index.mjs.map b/node_modules/dero-xswd-api/dist/index.mjs.map
index 0caa960..1a0a839 100644
--- a/node_modules/dero-xswd-api/dist/index.mjs.map
+++ b/node_modules/dero-xswd-api/dist/index.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/debug.ts","../src/utils.ts","../src/connection.ts","../src/xswd.ts","../src/types/request.ts"],"sourcesContent":["export default (DEBUG: boolean) => (label: string) =>\n  DEBUG ? (...data: any) => console.log(label + \":\", ...data) : () => {};\n","import {\n  ErrorResponse,\n  Response,\n  Result,\n  ResultResponse,\n} from \"./types/response\";\nimport { Entity } from \"./types/types\";\nimport { Method } from \"./types/request\";\n\nasync function hash(message: string) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  const hash = await crypto.subtle.digest(\"SHA-256\", data);\n  return buf2hex(hash);\n}\nfunction buf2hex(buffer: ArrayBuffer) {\n  return [...new Uint8Array(buffer)]\n    .map((x) => x.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n}\n\nexport async function generateAppId(appName: string): Promise<string> {\n  return await hash(appName);\n}\n\nexport async function sleep(timems: number) {\n  await new Promise((r) => setTimeout(r, timems));\n}\n\nexport function to<\n  E extends Entity,\n  M extends Method<E>,\n  R extends Result = Result\n>(\n  response: Response<E, M, R>\n): [ErrorResponse | undefined, ResultResponse<E, M> | undefined] {\n  return [\n    \"error\" in response ? (response.error as ErrorResponse) : undefined,\n    \"result\" in response\n      ? (response.result as ResultResponse<E, M>)\n      : undefined,\n  ];\n}\n","import { Method, JSONRPCRequestBody } from \"./types/request\";\nimport { AuthResponse, EventResponse, Response } from \"./types/response\";\nimport { AppInfo, Entity, EventType } from \"./types/types\";\n\nimport makeDebug from \"./debug\";\nimport { sleep } from \"./utils\";\nimport { Config } from \"./xswd\";\nlet debug = makeDebug(false)(\"connection\");\n\nexport enum ConnectionState {\n  Initializing = \"initializing\",\n  WaitingAuth = \"waitingAuth\",\n  Accepted = \"accepted\",\n  Refused = \"refused\",\n  Closed = \"closed\",\n}\n\nabstract class Connection {\n  id = 1;\n  AUTH_TIMEOUT: number | null = null;\n  METHOD_TIMEOUT: number | null = null;\n  BLOCK_TIMEOUT: number | null = null;\n  INTERVAL = 100;\n  constructor() {}\n  abstract initialize(): Promise<void>;\n  abstract close(): void;\n  abstract onclose(): void;\n\n  abstract sendSync<E extends Entity, M extends Method<E>>(\n    entity: E,\n    method: M,\n    body: Omit<JSONRPCRequestBody<typeof entity, typeof method>, \"id\">\n  ): Promise<Response<E, M, \"error\"> | Response<E, M, \"result\">>;\n\n  abstract _checkEvent(\n    eventType: EventType,\n    predicate?: (eventValue: any) => boolean\n  ): Promise<any>;\n}\n\nclass XSWDConnection extends Connection {\n  websocket: WebSocket | undefined;\n  ip: string;\n  port: number;\n  state = ConnectionState.Initializing;\n  responses: { [id: number]: null | any } = {};\n  events: {\n    [eventType: EventType | string]: {\n      processed: boolean;\n      value: any;\n      subscribed: false | \"auto\" | \"permanent\";\n      callback?: (value: any) => void;\n    };\n  } = {\n    new_topoheight: {\n      processed: true,\n      value: 0,\n      subscribed: false,\n    },\n    new_balance: {\n      processed: true,\n      value: 0,\n      subscribed: false,\n    },\n    new_entry: {\n      processed: true,\n      value: \"\",\n      subscribed: false,\n    },\n  };\n  appInfo: AppInfo;\n  buffer: string = \"\";\n  timeouts: Set<any> = new Set();\n\n  constructor(appInfo: AppInfo, config?: Config) {\n    super();\n    debug = makeDebug(config?.debug || false)(\"connection\");\n    this.appInfo = appInfo;\n\n    this.ip = config?.ip || \"localhost\";\n    this.port = config?.port || 44326;\n\n    this.AUTH_TIMEOUT = config?.timeout?.AUTH_TIMEOUT || null;\n    this.BLOCK_TIMEOUT = config?.timeout?.BLOCK_TIMEOUT || null;\n    this.METHOD_TIMEOUT = config?.timeout?.METHOD_TIMEOUT || null;\n  }\n  async close() {\n    console.warn(\"closing websocket\", this.timeouts);\n\n    this.timeouts.forEach((timeout) => clearTimeout(timeout));\n    this.websocket?.close();\n  }\n\n  onclose(): void {}\n\n  async initialize() {\n    return new Promise<void>((resolve, reject) => {\n      debug(\"initialize\");\n      if (\n        this.websocket !== undefined &&\n        this.websocket.readyState == WebSocket.OPEN\n      ) {\n        throw \"WebSocket is aleady alive\";\n      }\n      this.state = ConnectionState.Initializing;\n\n      const url = `ws://${this.ip}:${this.port}/xswd`;\n      this.websocket = new WebSocket(url);\n      debug(\"websocket created for \" + url);\n\n      this.websocket.onmessage = (message) => {\n        let data:\n          | AuthResponse\n          | EventResponse\n          | Response<Entity, Method<Entity>, \"error\">\n          | Response<Entity, Method<Entity>, \"result\">;\n\n        // fragmented messages handling\n        try {\n          // default parsing a single message\n          data = JSON.parse(message.data.toString());\n          debug(\"WebSocket:onmessage\", { data });\n        } catch (error) {\n          // sometimes the result is split in multiple message so we need to buffer\n          this.buffer = this.buffer + message.data.toString();\n          try {\n            // we keep parsing the buffer after updating it to check if the result is complete\n            data = JSON.parse(this.buffer);\n            // success => we empty the buffer\n            this.buffer = \"\";\n          } catch (error) {\n            // not parsable yet, better luck next message\n            return;\n          }\n        }\n\n        if (\"accepted\" in data) {\n          if (data.accepted === true) {\n            this.state = ConnectionState.Accepted;\n            debug(\"connection accepted\");\n            resolve();\n          } else if (data.accepted === false) {\n            this.state = ConnectionState.Refused;\n            debug(\"connection refused\", data);\n            reject(\"connection refused: \" + data.message);\n          }\n        } else if (\"error\" in data) {\n          const errorData: Response<Entity, Method<Entity>, \"error\"> = data;\n          reject(errorData.error.message);\n          this.handle(data);\n        } else if (\"result\" in data) {\n          if (\n            typeof data.result == \"object\" &&\n            data.result !== null &&\n            \"event\" in data.result\n          ) {\n            this.handleEvent(data as EventResponse);\n          } else {\n            this.handle(data);\n          }\n        }\n      };\n\n      this.websocket.onerror = (error) => {\n        this.state = ConnectionState.Closed;\n        reject(error);\n      };\n\n      this.websocket.onopen = () => {\n        debug(\"websocket connection opened, authorizing...\");\n        this.authorize(this.appInfo);\n        this.state = ConnectionState.WaitingAuth;\n        if (this.AUTH_TIMEOUT) {\n          setTimeout(() => reject(\"authorisation timeout\"), this.AUTH_TIMEOUT);\n        }\n      };\n\n      this.websocket.onclose = () => {\n        this.state = ConnectionState.Initializing;\n        this.websocket = undefined;\n        this.onclose();\n        debug(\"connection closed\");\n        reject(\"connection closed\");\n      };\n\n      debug(\"websocket handlers are set\");\n    });\n  }\n\n  private authorize(appInfo: AppInfo) {\n    const data = { ...appInfo };\n    debug(\"sending authorisation: \", { data });\n    this.websocket?.send(JSON.stringify(data));\n  }\n  private handle(data: any) {\n    this.responses[Number(data.id)] = data;\n  }\n\n  private handleEvent(data: EventResponse) {\n    this.events[data.result.event].value = data.result.value;\n    this.events[data.result.event].processed = false;\n    const callback = this.events[data.result.event].callback;\n    debug(\"Handling event\", { data, callback });\n\n    if (callback) {\n      callback(data.result.value);\n    }\n  }\n\n  private send(\n    entity: Entity,\n    method: Method<typeof entity>,\n    body: Omit<JSONRPCRequestBody<typeof entity, typeof method>, \"id\">\n  ): number {\n    debug(\"\\n\\n----------- REQUEST -------\", entity, method, \"\\n\");\n    if (this.state == ConnectionState.Accepted) {\n      const id = this.id;\n      this.id += 1;\n      const bodyWithId: JSONRPCRequestBody<typeof entity, typeof method> = {\n        ...body,\n        id,\n      };\n\n      this.websocket?.send(JSON.stringify(bodyWithId));\n      this.responses[id] = null;\n      return id;\n    } else {\n      throw \"sending without being connected\";\n    }\n  }\n\n  async sendSync<E extends Entity, M extends Method<E>>(\n    entity: E,\n    method: M,\n    body: Omit<JSONRPCRequestBody<typeof entity, typeof method>, \"id\">\n  ): Promise<Response<E, M, \"error\"> | Response<E, M, \"result\">> {\n    debug(\"sendSync:\", { body });\n\n    const id = this.send(entity, method, body);\n\n    await this._checkResponse(id);\n    const data = this.responses[id];\n\n    debug(\"Response:\");\n    debug(data);\n    /*if (\"result\" in data) {\n      if (\"stringkeys\" in data.result) {\n        if (\"C\" in data.result.stringkeys) {\n          debug({\n            ...data,\n            result: {\n              ...data.result,\n              stringkeys: { ...data.result.stringkeys, C: \"...\" },\n            },\n          });\n          //delete data.result.stringkeys.C;\n        }\n      }\n    }*/\n\n    delete this.responses[id];\n\n    return data;\n  }\n\n  private _checkResponse(id: number) {\n    return new Promise<void>(async (resolve, reject) => {\n      // setup a timeout for response checking\n      let timeout: any;\n      if (this.METHOD_TIMEOUT) {\n        timeout = setTimeout(() => {\n          // delete the timeout record\n          this.timeouts.delete(timeout);\n          reject(\"request timeout\");\n        }, this.METHOD_TIMEOUT);\n\n        // record this timeout (if we close we need to clear the handles)\n        this.timeouts.add(timeout);\n      }\n      // loop over time to see if the event has been received\n      for (let attempts = 1; ; attempts++) {\n        await sleep(this.INTERVAL * attempts); // double the time at each new attempts\n        debug(\"checking response\", id);\n\n        // if event hasn't already been processed\n        if (this.responses[id] !== null && this.responses[id] !== undefined) {\n          // handle\n          debug(`response ${id}`, this.responses[id]);\n          if (timeout !== undefined) {\n            this.timeouts.delete(timeout);\n          }\n          resolve();\n          break;\n        }\n      }\n    });\n  }\n\n  // TODO Typing\n  _checkEvent(\n    eventType: EventType,\n    predicate?: (eventValue: any) => boolean\n  ): Promise<any> {\n    return new Promise<any>(async (resolve, reject) => {\n      let timeout: any;\n      if (this.BLOCK_TIMEOUT) {\n        // setup a timeout for event checking\n        timeout = setTimeout(() => {\n          // delete the timeout record\n          this.timeouts.delete(timeout);\n          reject(\"event check timeout\");\n        }, this.BLOCK_TIMEOUT);\n\n        // record this timeout (if we close we need to clear the handles)\n        this.timeouts.add(timeout);\n      }\n      // loop over time to see if the event has been received\n      for (let attempts = 1; ; attempts++) {\n        await sleep(this.INTERVAL * attempts); // double the time at each new attempts\n        debug(\"checking event\", eventType);\n\n        // if there is no predicate or this is the target\n        if (predicate === undefined || predicate(this.events[eventType].value))\n          if (!this.events[eventType].processed) {\n            // if event hasn't already been processed\n            // handle\n            this.events[eventType].processed = true;\n            debug(\"checked event\", eventType);\n            if (timeout !== undefined) {\n              this.timeouts.delete(timeout);\n            }\n            resolve(this.events[eventType].value);\n            break;\n          }\n      }\n    });\n  }\n}\n\nclass FallbackConnection extends Connection {\n  url: string;\n  events = {};\n\n  constructor(url: string, config?: { debug?: boolean }) {\n    super();\n    debug = makeDebug(config?.debug || false)(\"connection\");\n    this.url = `${url}/json_rpc`;\n  }\n\n  async sendSync<E extends Entity, M extends Method<E>>(\n    entity: E,\n    method: M,\n    body: Omit<JSONRPCRequestBody<E, M>, \"id\">\n  ): Promise<Response<E, M, \"error\"> | Response<E, M, \"result\">> {\n    const id = this.id++;\n    const bodyWithId: JSONRPCRequestBody<Entity, Method<Entity>> = {\n      ...body,\n      id,\n    };\n\n    debug({ bodyWithId });\n    const response = await fetch(this.url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(bodyWithId),\n    });\n\n    const json = await response.json();\n\n    debug({ response: json }); // TODO\n\n    return json;\n  }\n\n  //\n  // Inactive methods\n  //\n\n  initialize(): Promise<void> {\n    throw \"Connection.initialize() shall not be used in fallback mode\";\n  }\n  close(): void {}\n  onclose(): void {}\n  send(\n    entity: Entity,\n    method: Method<Entity>,\n    body: Omit<JSONRPCRequestBody<Entity, Method<Entity>>, \"id\">\n  ): number {\n    throw \"Connection.send() shall not be used in fallback mode\";\n  }\n  _checkEvent(\n    eventType: EventType,\n    predicate?: ((eventValue: any) => boolean) | undefined\n  ): Promise<any> {\n    throw \"Connection._checkEvent() shall not be used in fallback mode\";\n  }\n}\n\nexport { XSWDConnection, Connection, FallbackConnection };\n","import { Connection, FallbackConnection, XSWDConnection } from \"./connection\";\nimport {\n  Echo,\n  GetTransferbyTXID,\n  GetTransfers,\n  MakeIntegratedAddress,\n  QueryKey,\n  SplitIntegratedAddress,\n  SCInvoke,\n  DEROGetBlock,\n  DEROGetBlockHeaderByHash,\n  DEROGetBlockHeaderByTopoHeight,\n  DEROGetBlockTemplate,\n  DEROGetEncryptedBalance,\n  DEROGetGasEstimate,\n  DEROGetRandomAddress,\n  DEROGetSC,\n  DEROGetTransaction,\n  DERONameToAddress,\n  Transfer,\n  GetBalance,\n  GetTrackedAssets,\n} from \"./types/request\";\nimport { AppInfo, EventType } from \"./types/types\";\nimport makeDebug from \"./debug\";\nimport { Entry, Balance, Topoheight } from \"./types/response\";\n\nlet debug = makeDebug(false)(\"xswd\");\n\nconst DEFAULT_FALLBACK_CONFIG = \"dero-api.mysrv.cloud:443\";\nconst DEFAULT_CONFIG = { ip: \"localhost\", port: 44326 };\nconst DEFAULT_TIMEOUT = {\n  AUTH_TIMEOUT: undefined,\n  METHOD_TIMEOUT: undefined,\n  BLOCK_TIMEOUT: undefined,\n};\n\nexport type Config = {\n  ip?: string;\n  port?: number;\n  debug?: boolean;\n  timeout?: {\n    AUTH_TIMEOUT?: number;\n    METHOD_TIMEOUT?: number;\n    BLOCK_TIMEOUT?: number;\n  };\n};\n\n// https://dero-api.mysrv.cloud/json_rpc\n// dero-node-ca.mysrv.cloud:10102\n// ams.derofoundation.org:11011\n// 213.171.208.37:18089 (MySrvCloud)\n// 5.161.123.196:11011 (MySrvCloud VA)\n// 51.222.86.51:11011 (RabidMining Pool)\n// 74.208.54.173:50404 (deronfts)\n// 85.214.253.170:53387 (mmarcel-vps)\n// 163.172.26.245:10505 (DeroStats)\n// 44.198.24.170:20000 (pieswap)\n\nexport class Api {\n  _connection: Connection;\n  _xswd_connection: XSWDConnection;\n  status: { initialized: false } | { initialized: true; fallback: boolean } = {\n    initialized: false,\n  };\n  _fallback_connection: FallbackConnection | null = null;\n  fallback_http_rpc: string | null = null;\n  appInfo: AppInfo;\n  config: Config;\n\n  constructor(\n    appInfo: AppInfo,\n    config?: Config,\n    // if xswd fails to connect, at least connect to a public node\n    fallback_http_rpc:\n      | false // any falsy means deactivate fallback\n      | null\n      | undefined\n      | string = DEFAULT_FALLBACK_CONFIG // or the default fallback value\n  ) {\n    debug = makeDebug(config?.debug || false)(\"xswd\");\n    debug(\"creating connection\");\n    checkAppInfo(appInfo);\n    this.appInfo = appInfo;\n    this.config = {\n      ...DEFAULT_CONFIG,\n      ...(config || {}),\n      timeout: { ...DEFAULT_TIMEOUT, ...(config?.timeout || {}) },\n    };\n    this._xswd_connection = new XSWDConnection(appInfo, config);\n    this._connection = this._xswd_connection;\n\n    if (fallback_http_rpc) {\n      this.fallback_http_rpc = fallback_http_rpc;\n      this._fallback_connection = new FallbackConnection(fallback_http_rpc, {\n        debug: config?.debug || false,\n      });\n      this._connection = this._fallback_connection;\n      this.status = { initialized: true, fallback: true };\n    }\n    /**\n\n   */\n  }\n\n  async initialize() {\n    this._xswd_connection = new XSWDConnection(this.appInfo, this.config);\n\n    await this._xswd_connection.initialize();\n    this.status = { initialized: true, fallback: false };\n    this._connection = this._xswd_connection;\n  }\n\n  async close() {\n    if (this.status.initialized) {\n      this._connection.close();\n    }\n  }\n\n  async subscribe(\n    { event, callback }: { event: EventType; callback?: any },\n    subscriptionType: \"auto\" | \"permanent\" = \"permanent\"\n  ) {\n    if (this.status.initialized && this._connection instanceof XSWDConnection) {\n      const subscription = await this._connection.sendSync(\n        \"wallet\",\n        \"Subscribe\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"Subscribe\",\n          params: { event },\n        }\n      );\n      if (\"result\" in subscription) {\n        if (subscription.result) {\n          this._connection.events[event].subscribed = subscriptionType;\n          // dont overwrite user callback\n          if (subscriptionType == \"permanent\") {\n            this._connection.events[event].callback = callback;\n          }\n        }\n        return subscription.result;\n      }\n      return false;\n    }\n    console.warn(\"cannot subscibe to events in fallback mode\");\n    return false;\n  }\n\n  async waitFor<\n    ET extends EventType,\n    EV = ET extends \"new_balance\"\n      ? Balance\n      : ET extends \"new_topoheight\"\n      ? Topoheight\n      : ET extends \"new_entry\"\n      ? Entry\n      : unknown\n  >(event: ET, predicate?: (eventValue: EV) => boolean): Promise<EV> {\n    if (this.status.initialized) {\n      return await this._connection._checkEvent(event, predicate);\n    }\n    if (this._connection instanceof XSWDConnection) {\n      throw \"cannot wait for event if connection is not initialized\";\n    }\n    throw \"cannot wait for event in fallback mode\";\n  }\n\n  wallet = {\n    _api: this as Api,\n\n    async Echo(params: Echo) {\n      return await this._api._connection.sendSync(\"wallet\", \"Echo\", {\n        jsonrpc: \"2.0\",\n        method: \"Echo\",\n        params,\n      });\n    },\n    async GetAddress() {\n      return await this._api._connection.sendSync(\"wallet\", \"GetAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"GetAddress\",\n        params: undefined,\n      });\n    },\n    async GetBalance(params: GetBalance = {}) {\n      return await this._api._connection.sendSync(\"wallet\", \"GetBalance\", {\n        jsonrpc: \"2.0\",\n        method: \"GetBalance\",\n        params,\n      });\n    },\n    async GetHeight() {\n      return await this._api._connection.sendSync(\"wallet\", \"GetHeight\", {\n        jsonrpc: \"2.0\",\n        method: \"GetHeight\",\n        params: undefined,\n      });\n    },\n    async GetTransferbyTXID(params: GetTransferbyTXID) {\n      return await this._api._connection.sendSync(\n        \"wallet\",\n        \"GetTransferbyTXID\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"GetTransferbyTXID\",\n          params,\n        }\n      );\n    },\n    async GetTransfers(params: GetTransfers = {}) {\n      return await this._api._connection.sendSync(\"wallet\", \"GetTransfers\", {\n        jsonrpc: \"2.0\",\n        method: \"GetTransfers\",\n        params,\n      });\n    },\n\n    async GetTrackedAssets(params: GetTrackedAssets) {\n      return await this._api._connection.sendSync(\n        \"wallet\",\n        \"GetTrackedAssets\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"GetTrackedAssets\",\n          params,\n        }\n      );\n    },\n\n    async MakeIntegratedAddress(params: MakeIntegratedAddress) {\n      return await this._api._connection.sendSync(\n        \"wallet\",\n        \"MakeIntegratedAddress\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"MakeIntegratedAddress\",\n          params,\n        }\n      );\n    },\n    async SplitIntegratedAddress(params: SplitIntegratedAddress) {\n      return await this._api._connection.sendSync(\n        \"wallet\",\n        \"SplitIntegratedAddress\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"SplitIntegratedAddress\",\n          params,\n        }\n      );\n    },\n    async QueryKey(params: QueryKey) {\n      return await this._api._connection.sendSync(\"wallet\", \"QueryKey\", {\n        jsonrpc: \"2.0\",\n        method: \"QueryKey\",\n        params,\n      });\n    },\n    async transfer(params: Transfer) {\n      const response = await this._api._connection.sendSync(\n        \"wallet\",\n        \"transfer\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"transfer\",\n          params,\n        }\n      );\n      return response;\n    },\n    async scinvoke(params: SCInvoke) {\n      const response = await this._api._connection.sendSync(\n        \"wallet\",\n        \"scinvoke\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"scinvoke\",\n          params,\n        }\n      );\n\n      if (\"error\" in response) {\n        throw \"could not scinvoke: \" + response.error.message;\n      }\n\n      return response;\n    },\n  };\n  node = {\n    _api: this as Api,\n\n    async Echo(params: Echo) {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.Echo\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.Echo\",\n        params,\n      });\n    },\n    async Ping() {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.Ping\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.Ping\",\n        params: undefined,\n      });\n    },\n    async GetInfo() {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.GetInfo\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetInfo\",\n        params: undefined,\n      });\n    },\n    async GetBlock(params: DEROGetBlock) {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.GetBlock\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlock\",\n        params,\n      });\n    },\n    async GetBlockHeaderByTopoHeight(params: DEROGetBlockHeaderByTopoHeight) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetBlockHeaderByTopoHeight\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetBlockHeaderByTopoHeight\",\n          params,\n        }\n      );\n    },\n    async GetBlockHeaderByHash(params: DEROGetBlockHeaderByHash) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetBlockHeaderByHash\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetBlockHeaderByHash\",\n          params,\n        }\n      );\n    },\n    async GetTxPool() {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.GetTxPool\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetTxPool\",\n        params: undefined,\n      });\n    },\n    async GetRandomAddress(params: DEROGetRandomAddress = {}) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetRandomAddress\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetRandomAddress\",\n          params,\n        }\n      );\n    },\n    async GetTransaction(params: DEROGetTransaction) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetTransaction\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetTransaction\",\n          params,\n        }\n      );\n    },\n    /*async SendRawTransaction(params: DEROSendRawTransaction) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.SendRawTransaction\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.SendRawTransaction\",\n          params,\n        }\n      );\n    },*/\n    async GetHeight() {\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.GetHeight\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetHeight\",\n        params: undefined,\n      });\n    },\n    async GetBlockCount() {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetBlockCount\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetBlockCount\",\n          params: undefined,\n        }\n      );\n    },\n    async GetLastBlockHeader() {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetLastBlockHeader\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetLastBlockHeader\",\n          params: undefined,\n        }\n      );\n    },\n    async GetBlockTemplate(params: DEROGetBlockTemplate) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetBlockTemplate\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetBlockTemplate\",\n          params,\n        }\n      );\n    },\n    async GetEncryptedBalance(params: DEROGetEncryptedBalance) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetEncryptedBalance\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetEncryptedBalance\",\n          params,\n        }\n      );\n    },\n    async GetSC(params: DEROGetSC, waitAfterNewBlock?: true) {\n      if (waitAfterNewBlock) {\n        debug(\"waiting for new block\");\n        this._api.subscribe({ event: \"new_topoheight\" }, \"auto\");\n        await this._api.waitFor(\"new_topoheight\");\n      }\n      return await this._api._connection.sendSync(\"daemon\", \"DERO.GetSC\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetSC\",\n        params,\n      });\n    },\n    async GetGasEstimate(params: DEROGetGasEstimate) {\n      // use gasEstimateSCArgs() to simplify usage\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.GetGasEstimate\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.GetGasEstimate\",\n          params,\n        }\n      );\n    },\n    async NameToAddress(params: DERONameToAddress) {\n      return await this._api._connection.sendSync(\n        \"daemon\",\n        \"DERO.NameToAddress\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.NameToAddress\",\n          params,\n        }\n      );\n    },\n  };\n}\n\nfunction checkAppInfo(appInfo: AppInfo) {\n  if (appInfo.name !== undefined && appInfo.name.length == 0) {\n    throw \"invalid app name\";\n  }\n  if (appInfo.description !== undefined && appInfo.description.length == 0) {\n    throw \"invalid app description\";\n  }\n  if (appInfo.id !== undefined && appInfo.id.length != 64) {\n    throw \"invalid app id\";\n  }\n}\n","import {\n  Address,\n  DVMString,\n  Entity,\n  EventType,\n  Hash,\n  SCCode,\n  Uint64,\n} from \"./types\";\n\nexport type JSONRPCRequest = {\n  method: \"POST\";\n  headers: {\n    \"Content-Type\": \"application/json\";\n  };\n  body: JSONRPCRequestBody<Entity, Method<Entity>>;\n};\n\nexport type JSONRPCRequestBody<E extends Entity, M extends Method<E>> = {\n  jsonrpc: \"2.0\";\n  id: string | number;\n  method: M;\n  params: Params<E, M>;\n};\n\nexport type Method<E extends Entity> = E extends \"daemon\"\n  ?\n      | \"DERO.Echo\"\n      | \"DERO.Ping\"\n      | \"DERO.GetInfo\"\n      | \"DERO.GetBlock\"\n      | \"DERO.GetBlockHeaderByTopoHeight\"\n      | \"DERO.GetBlockHeaderByHash\"\n      | \"DERO.GetTxPool\"\n      | \"DERO.GetRandomAddress\"\n      | \"DERO.GetTransaction\"\n      | \"DERO.SendRawTransaction\"\n      | \"DERO.GetHeight\"\n      | \"DERO.GetBlockCount\"\n      | \"DERO.GetLastBlockHeader\"\n      | \"DERO.GetBlockTemplate\"\n      | \"DERO.GetEncryptedBalance\"\n      | \"DERO.GetSC\"\n      | \"DERO.GetGasEstimate\"\n      | \"DERO.NameToAddress\"\n  :\n      | \"Echo\"\n      | \"GetAddress\"\n      | \"GetBalance\"\n      | \"GetHeight\"\n      | \"GetTransferbyTXID\"\n      | \"GetTransfers\"\n      | \"GetTrackedAssets\"\n      | \"MakeIntegratedAddress\"\n      | \"SplitIntegratedAddress\"\n      | \"QueryKey\"\n      | \"transfer\"\n      | \"scinvoke\"\n      | \"Subscribe\";\n\nexport type Params<\n  E extends Entity,\n  M extends Method<E>\n> = M extends \"DERO.Echo\"\n  ? Echo\n  : M extends \"DERO.Ping\"\n  ? undefined\n  : M extends \"DERO.GetInfo\"\n  ? undefined\n  : M extends \"DERO.GetBlock\"\n  ? DEROGetBlock\n  : M extends \"DERO.GetBlockHeaderByTopoHeight\"\n  ? DEROGetBlockHeaderByTopoHeight\n  : M extends \"DERO.GetBlockHeaderByHash\"\n  ? DEROGetBlockHeaderByHash\n  : M extends \"DERO.GetTxPool\"\n  ? undefined\n  : M extends \"DERO.GetRandomAddress\"\n  ? DEROGetRandomAddress\n  : M extends \"DERO.GetTransaction\"\n  ? DEROGetTransaction\n  : M extends \"DERO.SendRawTransaction\"\n  ? DEROSendRawTransaction\n  : M extends \"DERO.GetHeight\"\n  ? undefined\n  : M extends \"DERO.GetBlockCount\"\n  ? undefined\n  : M extends \"DERO.GetLastBlockHeader\"\n  ? undefined\n  : M extends \"DERO.GetBlockTemplate\"\n  ? DEROGetBlockTemplate\n  : M extends \"DERO.GetEncryptedBalance\"\n  ? DEROGetEncryptedBalance\n  : M extends \"DERO.GetSC\"\n  ? DEROGetSC\n  : M extends \"DERO.GetGasEstimate\"\n  ? DEROGetGasEstimate\n  : M extends \"DERO.NameToAddress\"\n  ? DERONameToAddress\n  : M extends \"GetAddress\"\n  ? undefined\n  : M extends \"GetBalance\"\n  ? GetBalance\n  : M extends \"GetHeight\"\n  ? undefined\n  : M extends \"GetTrackedAssets\"\n  ? GetTrackedAssets\n  : M extends \"GetTransferbyTXID\"\n  ? GetTransferbyTXID\n  : M extends \"GetTransfers\"\n  ? GetTransfers\n  : M extends \"MakeIntegratedAddress\"\n  ? MakeIntegratedAddress\n  : M extends \"SplitIntegratedAddress\"\n  ? SplitIntegratedAddress\n  : M extends \"QueryKey\"\n  ? QueryKey\n  : M extends \"transfer\"\n  ? Transfer\n  : M extends \"scinvoke\"\n  ? SCInvoke\n  : M extends \"Subscribe\"\n  ? { event: EventType }\n  : Echo;\n\nexport type Echo = DVMString[];\n\nexport type WalletTransfer = {\n  amount?: Uint64;\n  burn?: Uint64;\n  destination?: string;\n  scid?: Hash;\n  payload_rpc?: Arguments;\n};\n\ntype ArgumentType = Uint64 | DVMString | Hash;\ntype Argument<AT extends ArgumentType> = {\n  name: DVMString;\n  datatype: AT extends Uint64\n    ? \"U\"\n    : AT extends Hash | DVMString\n    ? \"H\" | \"S\"\n    : unknown;\n  value: AT;\n};\n\ntype Arguments = Argument<ArgumentType>[];\n\nexport type DEROGetBlock = {\n  hash?: Hash;\n  height?: Uint64;\n};\n\nexport type DEROGetBlockHeaderByTopoHeight = {\n  topoheight: Uint64;\n};\n\nexport type DEROGetBlockHeaderByHash = {\n  hash: Hash;\n};\n\nexport type DEROGetRandomAddress = {\n  scid?: Hash;\n};\n\nexport type DEROGetTransaction = {\n  txs_hashes: Hash[];\n  decode_as_json?: Uint64;\n};\n\nexport type DEROSendRawTransaction = {\n  tx_as_hex: DVMString;\n};\n\nexport type DEROGetBlockTemplate = {\n  wallet_address: DVMString;\n  block?: boolean;\n  miner?: DVMString;\n};\n\nexport type DEROGetEncryptedBalance = {\n  address: DVMString;\n  topoheight: Uint64;\n  scid?: Hash;\n  treehash?: Hash;\n};\n\nexport type DEROGetSC = {\n  scid: Hash;\n  code?: boolean;\n  variables?: boolean;\n  topoheight?: Uint64;\n  keysuint64?: Uint64[];\n  keysstring?: DVMString[];\n  keysbytes?: Int8Array[];\n};\n\n// TODO rename transferSCArgs, used in both transfer and gasEstimate\nexport function gasEstimateSCArgs(\n  scid: Hash,\n  entrypoint: string,\n  args: { name: string; value: DVMString | Uint64 }[]\n): Argument<ArgumentType>[] {\n  return [\n    {\n      name: \"SC_ACTION\",\n      datatype: \"U\",\n      value: 0,\n    },\n    {\n      name: \"SC_ID\",\n      datatype: \"H\",\n      value: scid,\n    },\n    ...scinvokeSCArgs(entrypoint, args),\n  ];\n}\n\nexport function scinvokeSCArgs(\n  entrypoint: string,\n  args: { name: string; value: DVMString | Uint64 }[]\n): Argument<ArgumentType>[] {\n  const formattedArgs: Argument<ArgumentType>[] = args.map(\n    ({ name, value }) => ({\n      name,\n      datatype: typeof value == \"number\" ? \"U\" : \"S\", //? bigint?\n      value,\n    })\n  );\n  return [\n    {\n      name: \"entrypoint\",\n      datatype: \"S\",\n      value: entrypoint,\n    },\n    ...formattedArgs,\n  ];\n}\n\nexport type DEROGetGasEstimate = {\n  transfers?: WalletTransfer[];\n  sc?: SCCode;\n  sc_rpc?: Argument<ArgumentType>[];\n  signer?: Address;\n};\n\nexport type DERONameToAddress = {\n  name: DVMString;\n  topoheight: Uint64;\n};\n\nexport type GetBalance = {\n  scid?: Hash;\n};\n\nexport type GetTrackedAssets = {\n  only_positive_balances: boolean;\n  skip_balance_check: boolean;\n};\n\nexport type GetTransferbyTXID = {\n  hash?: Hash;\n  txid?: Hash;\n};\n\nexport type GetTransfers = {\n  scid?: Hash;\n  coinbase?: boolean;\n  in?: boolean;\n  out?: boolean;\n  min_height?: Uint64;\n  max_height?: Uint64;\n  sender?: DVMString;\n  receiver?: DVMString;\n  dstport?: Uint64;\n  srcport?: Uint64;\n};\n\nexport type MakeIntegratedAddress = {\n  address?: DVMString;\n  payload_rpc?: Argument<ArgumentType>;\n};\n\nexport type SplitIntegratedAddress = {\n  integrated_address: DVMString;\n};\n\nexport type QueryKey = { key_type: \"mnemonic\" };\n\nexport type Transfer = {\n  transfers?: WalletTransfer[];\n  sc?: SCCode;\n  sc_rpc?: Arguments;\n  ringsize?: Uint64;\n  scid?: Hash;\n  fees?: Uint64;\n  signer?: Address;\n};\n\nexport type SCInvoke = {\n  scid: Hash;\n  sc_rpc: Arguments;\n\n  sc_dero_deposit?: Uint64;\n  sc_token_deposit?: Uint64;\n  ringsize?: Uint64;\n};\n"],"mappings":"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","names":["hash","ConnectionState","error","debug"]}
\ No newline at end of file
+{"version":3,"sources":["../src/types/types.ts","../src/debug.ts","../src/xswd.ts","../src/utils.ts","../src/types/request.ts"],"sourcesContent":["export type Uint64 = number; // bigint ?\nexport type DVMString = string;\nexport type Hash = string;\nexport type SCCode = string;\nexport type Address = string;\nexport type DataType = \"S\" | \"U\" | \"H\";\n\nexport type Stringkeys = { [key: string]: number | string };\n\nexport type Entity = \"wallet\" | \"daemon\";\n\nexport type Config = {\n  address?: string;\n  port?: number;\n  debug?: boolean;\n  timeout?: {\n    AUTH_TIMEOUT?: number;\n    METHOD_TIMEOUT?: number;\n    BLOCK_TIMEOUT?: number;\n  };\n  secure?: boolean;\n};\n\nexport enum ConnectionState {\n  Initializing = \"initializing\",\n  WaitingAuth = \"waitingAuth\",\n  Accepted = \"accepted\",\n  Refused = \"refused\",\n  Closed = \"closed\",\n}\n\nexport type AppInfo = {\n  //! security threat => token based communication (generated by wallet)\n  id: string; //TODO\n  name: string;\n  description: string;\n  url?: string;\n};\n\nexport type EventType = \"new_topoheight\" | \"new_entry\" | \"new_balance\";\n","export default (DEBUG: boolean) => (label: string) =>\n  DEBUG ? (...data: any) => console.log(label + \":\", ...data) : () => {};\n","import {\n  Echo,\n  GetTransferbyTXID,\n  GetTransfers,\n  MakeIntegratedAddress,\n  QueryKey,\n  SplitIntegratedAddress,\n  SCInvoke,\n  DEROGetBlock,\n  DEROGetBlockHeaderByHash,\n  DEROGetBlockHeaderByTopoHeight,\n  DEROGetBlockTemplate,\n  DEROGetEncryptedBalance,\n  DEROGetGasEstimate,\n  DEROGetRandomAddress,\n  DEROGetSC,\n  DEROGetTransaction,\n  DERONameToAddress,\n  Transfer,\n  GetBalance,\n  GetTrackedAssets,\n  Method,\n  JSONRPCRequestBody,\n} from \"./types/request\";\nimport {\n  AppInfo,\n  Config,\n  ConnectionState,\n  Entity,\n  EventType,\n} from \"./types/types\";\nimport makeDebug from \"./debug\";\nimport {\n  Response,\n  Entry,\n  Balance,\n  Topoheight,\n  Result,\n  AuthResponse,\n  EventResponse,\n} from \"./types/response\";\n\nimport { Chan } from \"@lesomnus/channel\";\nimport { sleep } from \"./utils\";\n\nlet debug = makeDebug(false)(\"xswd\");\n\nconst DEFAULT_CONFIG: Config = {\n  address: \"127.0.0.1\",\n  port: 44326,\n  secure: false,\n  debug: false,\n};\nconst DEFAULT_TIMEOUT = {\n  AUTH_TIMEOUT: undefined,\n  METHOD_TIMEOUT: undefined,\n  BLOCK_TIMEOUT: undefined,\n};\nconst CHECK_INTERVAL = 500;\n\nfunction checkConfig(config: Config) {\n  if (!config.address) {\n    throw \"missing address in fallback config\";\n  }\n}\n\nenum ConnectionType {\n  XSWD = \"xswd\",\n  Fallback = \"fallback\",\n}\n\nexport class Api {\n  connection: { [ct in ConnectionType]: WebSocket | null } = {\n    xswd: null,\n    fallback: null,\n  };\n\n  state: { [ct in ConnectionType]: ConnectionState } = {\n    xswd: ConnectionState.Closed,\n    fallback: ConnectionState.Closed,\n  };\n\n  buffer: string = \"\";\n\n  appInfo: AppInfo;\n  config: {\n    [k in ConnectionType]: k extends ConnectionType.XSWD\n      ? Config\n      : Config | null;\n  };\n\n  response: Chan<Response<Entity, Method<Entity>, Result>> = new Chan(0);\n  subscriptions: {\n    events: {\n      [et in EventType]: {\n        enabled: boolean;\n        waiting: Chan<any>[]; // when using waitfor a channel is added here\n        callback?: (eventValue?: any) => void; // callback defined on subscription\n      };\n    };\n  } = {\n    events: {\n      new_topoheight: {\n        enabled: false,\n        waiting: [],\n        callback: undefined,\n      },\n      new_entry: {\n        enabled: false,\n        waiting: [],\n        callback: undefined,\n      },\n      new_balance: {\n        enabled: false,\n        waiting: [],\n        callback: undefined,\n      },\n    },\n  };\n\n  private nextId: number = 1;\n\n  public get mode(): ConnectionType {\n    return this.state.xswd == ConnectionState.Accepted\n      ? ConnectionType.XSWD\n      : this.state.fallback != ConnectionState.Accepted\n      ? ConnectionType.XSWD\n      : ConnectionType.Fallback;\n  }\n\n  constructor(\n    appInfo: AppInfo,\n    config?: Config,\n    // if xswd fails to connect, at least connect to a public node\n    fallback_config: Config | null = null // no fallback setup by default\n  ) {\n    debug = makeDebug(config?.debug || false)(\"xswd\");\n    debug(\"creating connection\");\n\n    checkAppInfo(appInfo);\n    this.appInfo = appInfo;\n    if (fallback_config) {\n      checkConfig(fallback_config);\n      debug(\"configured fallback:\", fallback_config);\n    }\n\n    this.config = {\n      xswd: {\n        ...DEFAULT_CONFIG,\n        ...(config || {}),\n        timeout: { ...DEFAULT_TIMEOUT, ...(config?.timeout || {}) },\n      },\n      fallback: fallback_config,\n    };\n  }\n\n  // deprecated\n  async initialize() {\n    debug(\"initializing api\");\n    if (this.config.fallback) {\n      await this.initializeFallback().finally(async () => {\n        await this.initializeXSWD();\n      });\n    } else {\n      await this.initializeXSWD();\n    }\n  }\n\n  async initializeFallback() {\n    return new Promise<void>(async (resolve, reject) => {\n      debug(\"initializing fallback\");\n\n      if (this.config.fallback) {\n        this._initializeWebsocket(ConnectionType.Fallback)\n          .then(() => {\n            debug(\"fallback intitialized\");\n            resolve();\n          })\n          .catch((error) => {\n            console.warn(\"failed to initialize fallback:\", error);\n            reject(error);\n          });\n      } else {\n        reject(\"fallback has no config\");\n      }\n    });\n  }\n\n  async initializeXSWD() {\n    return new Promise<void>(async (resolve, reject) => {\n      debug(\"initializing xswd\");\n\n      this._initializeWebsocket(ConnectionType.XSWD)\n        .then(() => {\n          debug(\"xswd initialized\");\n          this.closeFallback();\n\n          resolve();\n        })\n        .catch((error) => {\n          if (this.state.fallback == ConnectionState.Accepted) {\n            console.warn(\"failed to initialize xswd. staying in fallback mode\");\n            console.error(error);\n            reject(error);\n          } else {\n            console.error(\"failed to initialize xswd or fallback:\", error);\n            reject(error);\n          }\n        });\n    });\n  }\n\n  async _initializeWebsocket(connectionType: ConnectionType) {\n    return new Promise<void>((resolve, reject) => {\n      debug(\"initialize \" + connectionType);\n      const websocket = this.connection[connectionType];\n\n      if (websocket !== null && websocket.readyState == WebSocket.OPEN) {\n        throw \"WebSocket is aleady alive\";\n      }\n\n      this.state[connectionType] = ConnectionState.Initializing;\n      const config = this.config[connectionType];\n      if (config != null) {\n        const protocol = config.secure ? \"wss\" : \"ws\";\n        const port = config.port ? `:${config.port}` : \"\";\n        const path = connectionType == ConnectionType.XSWD ? \"xswd\" : \"ws\";\n        const url = `${protocol}://${config.address}${port}/${path}`;\n\n        this.connection[connectionType] = new WebSocket(url);\n        debug(connectionType + \" websocket created for \" + url);\n\n        this._setupHandlers(connectionType, resolve, reject);\n      }\n    });\n  }\n\n  _handleFragmentedData(\n    message: MessageEvent<any>\n  ):\n    | AuthResponse\n    | EventResponse\n    | Response<Entity, Method<Entity>, \"error\">\n    | Response<Entity, Method<Entity>, \"result\">\n    | null {\n    //debug(\"WebSocket:onmessage\", { message });\n    // fragmented messages handling\n    try {\n      // default parsing a single message\n      return JSON.parse(message.data.toString());\n    } catch (error) {\n      // sometimes the result is split in multiple message so we need to buffer\n      this.buffer = this.buffer + message.data.toString();\n      try {\n        // we keep parsing the buffer after updating it to check if the result is complete\n        const data = JSON.parse(this.buffer);\n        // success => we empty the buffer\n        this.buffer = \"\";\n        return data;\n      } catch (error) {\n        // not parsable yet, better luck next message\n        return null;\n      }\n    }\n  }\n\n  async _setupHandlers(\n    connectionType: ConnectionType,\n    resolve: (value: void | PromiseLike<void>) => void,\n    reject: (reason?: any) => void\n  ) {\n    const websocket = this.connection[connectionType];\n    if (websocket) {\n      websocket.onmessage = async (message) => {\n        let data:\n          | AuthResponse\n          | EventResponse\n          | Response<Entity, Method<Entity>, \"error\">\n          | Response<Entity, Method<Entity>, \"result\">\n          | null;\n\n        data = this._handleFragmentedData(message); // some message are not received in a single frame, this function buffers until message is parsable\n        if (data == null) return;\n\n        if (connectionType == ConnectionType.XSWD) {\n          if (\"accepted\" in data) {\n            if (data.accepted === true) {\n              this.state[ConnectionType.XSWD] = ConnectionState.Accepted;\n              debug(\"connection accepted\");\n              resolve();\n            } else if (data.accepted === false) {\n              this.state[ConnectionType.XSWD] = ConnectionState.Refused;\n              debug(\"connection refused\", data);\n              reject(\"connection refused: \" + data.message);\n            }\n          }\n        }\n\n        if (\"error\" in data) {\n          const errorData: Response<Entity, Method<Entity>, \"error\"> = data;\n          await this.response.send(errorData);\n          reject(errorData.error.message);\n        } else if (\"result\" in data) {\n          // event\n          if (\n            connectionType == ConnectionType.XSWD &&\n            typeof data.result == \"object\" &&\n            data.result != null &&\n            \"event\" in data.result\n          ) {\n            const eventData = data as EventResponse;\n            const eventType = eventData.result.event;\n            const eventValue = eventData.result.value;\n\n            if (this.subscriptions.events[eventType].enabled) {\n              const callback = this.subscriptions.events[eventType].callback;\n              if (callback !== undefined) callback(eventValue);\n\n              this.subscriptions.events[eventType].waiting.forEach(\n                (waitingChannel) => {\n                  waitingChannel.send(eventValue);\n                }\n              );\n              return;\n            }\n          }\n          // normal response\n          await this.response.send(data);\n        }\n      };\n\n      websocket.onerror = (error) => {\n        this.state[connectionType] = ConnectionState.Closed;\n        reject(error);\n      };\n\n      websocket.onopen = () => {\n        if (connectionType == ConnectionType.Fallback) {\n          debug(\"fallback websocket connection opened.\");\n          resolve();\n          this.state[connectionType] = ConnectionState.Accepted;\n        } else {\n          debug(\"xswd websocket connection opened, authorizing...\");\n          this.authorize(this.appInfo);\n          this.state.xswd = ConnectionState.WaitingAuth;\n          if (this.config.xswd.timeout?.AUTH_TIMEOUT) {\n            setTimeout(\n              () => reject(\"authorisation timeout\"),\n              this.config.xswd.timeout?.AUTH_TIMEOUT\n            );\n          }\n        }\n      };\n\n      websocket.onclose = (ev) => {\n        this.state[connectionType] = ConnectionState.Closed;\n        this.connection[connectionType] = null;\n        this.onclose(connectionType, ev);\n        debug(connectionType + \" connection closed\");\n        reject(connectionType + \" connection closed\");\n      };\n\n      debug(connectionType + \" websocket handlers are set\");\n    }\n  }\n\n  // callback meant to be set by user\n  onclose(connectionType: ConnectionType, ev: CloseEvent) {}\n\n  async closeXSWD() {\n    if (\n      this.state.xswd == ConnectionState.Accepted ||\n      this.state.xswd == ConnectionState.WaitingAuth\n    ) {\n      debug(\"closing xswd\");\n      this.connection.xswd?.close();\n      this.state.xswd = ConnectionState.Closed;\n    }\n  }\n  async closeFallback() {\n    if (this.state.fallback == ConnectionState.Accepted) {\n      debug(\"closing fallback\");\n      this.connection.fallback?.close();\n\n      this.state.fallback = ConnectionState.Closed;\n    }\n  }\n\n  async close() {\n    this.closeFallback();\n    this.closeXSWD();\n  }\n\n  async Send<E extends Entity, M extends Method<E>>( //! previously sendSync\n    entity: E,\n    method: M,\n    body: Omit<JSONRPCRequestBody<E, M>, \"id\">\n  ) {\n    return new Promise<Response<E, M, \"error\"> | Response<E, M, \"result\">>(\n      async (resolve, reject) => {\n        if (this.mode == ConnectionType.Fallback && entity == \"wallet\") {\n          reject(\"cannot send to wallet in fallback mode.\");\n        }\n\n        debug(\"\\n\\n----------- REQUEST -------\", entity, method, \"\\n\");\n\n        const websocket = this.connection[this.mode];\n\n        if (this.state[this.mode] == ConnectionState.Accepted && websocket) {\n          // assing id to the body\n          const id = this.nextId;\n          this.nextId += 1;\n          const bodyWithId: JSONRPCRequestBody<typeof entity, typeof method> = {\n            ...body,\n            id,\n          };\n\n          /*this.config[this.mode]?.debug &&\n            console.dir({ bodyWithId }, { depth: null });*/\n          debug(\"sending\", bodyWithId);\n\n          // send data\n          websocket.send(JSON.stringify(bodyWithId));\n\n          // listen for the response\n          for (;;) {\n            const response = await this.response.recv();\n            // if ids mismatch\n            if (response.id != String(id)) {\n              // send it back to the channel\n              debug(\"id mismatch: \", response.id, String(id), \", resetting\");\n              await this.response.send(response);\n              await sleep(CHECK_INTERVAL);\n            } else {\n              debug(\"id match\", { response });\n\n              resolve(\n                response as Response<E, M, \"error\"> | Response<E, M, \"result\">\n              );\n              return;\n            }\n          }\n        } else {\n          reject(\"sending without being connected\");\n          return;\n        }\n      }\n    );\n  }\n\n  async subscribe({\n    event,\n    callback,\n  }: {\n    event: EventType;\n    callback?: (value: any) => void;\n  }) {\n    if (\n      this.state.xswd == ConnectionState.Accepted &&\n      this.mode === ConnectionType.XSWD\n    ) {\n      const subscription = await this.Send(\"wallet\", \"Subscribe\", {\n        jsonrpc: \"2.0\",\n        method: \"Subscribe\",\n        params: { event },\n      });\n      if (\"result\" in subscription) {\n        if (subscription.result) {\n          this.subscriptions.events[event].enabled = true;\n          this.subscriptions.events[event].callback = callback;\n        }\n        return subscription.result;\n      }\n      return false;\n    }\n    console.warn(\"cannot subscibe to events in fallback mode\");\n    return false;\n  }\n\n  async waitFor<\n    ET extends EventType,\n    EV = ET extends \"new_balance\"\n      ? Balance\n      : ET extends \"new_topoheight\"\n      ? Topoheight\n      : ET extends \"new_entry\"\n      ? Entry\n      : unknown\n  >(event: ET, predicate?: (eventValue: EV) => boolean): Promise<EV> {\n    if (this.mode == ConnectionType.Fallback) {\n      throw \"cannot wait for event in fallback mode\";\n    }\n\n    if (!this.subscriptions.events[event].enabled) {\n      throw `event ${event} has not been subscribed to`;\n    }\n\n    if (this.state.xswd == ConnectionState.Accepted) {\n      const c = new Chan<any>();\n      this.subscriptions.events[event].waiting.push(c);\n      for (;;) {\n        const value = await c.recv();\n        if (predicate === undefined) {\n          return value;\n        } else if (predicate && predicate(value)) {\n          return value;\n        }\n      }\n    } else {\n      throw \"cannot wait for event if connection is not initialized\";\n    }\n  }\n\n  private authorize(appInfo: AppInfo) {\n    const websocket = this.connection.xswd;\n    if (websocket) {\n      const data = { ...appInfo };\n      debug(\"sending authorisation: \", { data });\n      websocket.send(JSON.stringify(data));\n    }\n  }\n\n  wallet = {\n    _api: this as Api,\n\n    async Echo(params: Echo) {\n      return await this._api.Send(\"wallet\", \"Echo\", {\n        jsonrpc: \"2.0\",\n        method: \"Echo\",\n        params,\n      });\n    },\n    async GetAddress() {\n      return await this._api.Send(\"wallet\", \"GetAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"GetAddress\",\n        params: undefined,\n      });\n    },\n    async GetBalance(params: GetBalance = {}) {\n      return await this._api.Send(\"wallet\", \"GetBalance\", {\n        jsonrpc: \"2.0\",\n        method: \"GetBalance\",\n        params,\n      });\n    },\n    async GetHeight() {\n      return await this._api.Send(\"wallet\", \"GetHeight\", {\n        jsonrpc: \"2.0\",\n        method: \"GetHeight\",\n        params: undefined,\n      });\n    },\n    async GetTransferbyTXID(params: GetTransferbyTXID) {\n      return await this._api.Send(\"wallet\", \"GetTransferbyTXID\", {\n        jsonrpc: \"2.0\",\n        method: \"GetTransferbyTXID\",\n        params,\n      });\n    },\n    async GetTransfers(params: GetTransfers = {}) {\n      return await this._api.Send(\"wallet\", \"GetTransfers\", {\n        jsonrpc: \"2.0\",\n        method: \"GetTransfers\",\n        params,\n      });\n    },\n\n    async GetTrackedAssets(params: GetTrackedAssets) {\n      return await this._api.Send(\"wallet\", \"GetTrackedAssets\", {\n        jsonrpc: \"2.0\",\n        method: \"GetTrackedAssets\",\n        params,\n      });\n    },\n\n    async MakeIntegratedAddress(params: MakeIntegratedAddress) {\n      return await this._api.Send(\"wallet\", \"MakeIntegratedAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"MakeIntegratedAddress\",\n        params,\n      });\n    },\n    async SplitIntegratedAddress(params: SplitIntegratedAddress) {\n      return await this._api.Send(\"wallet\", \"SplitIntegratedAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"SplitIntegratedAddress\",\n        params,\n      });\n    },\n    async QueryKey(params: QueryKey) {\n      return await this._api.Send(\"wallet\", \"QueryKey\", {\n        jsonrpc: \"2.0\",\n        method: \"QueryKey\",\n        params,\n      });\n    },\n    async transfer(params: Transfer) {\n      const response = await this._api.Send(\"wallet\", \"transfer\", {\n        jsonrpc: \"2.0\",\n        method: \"transfer\",\n        params,\n      });\n      return response;\n    },\n    async scinvoke(params: SCInvoke) {\n      const response = await this._api.Send(\"wallet\", \"scinvoke\", {\n        jsonrpc: \"2.0\",\n        method: \"scinvoke\",\n        params,\n      });\n\n      if (\"error\" in response) {\n        throw \"could not scinvoke: \" + response.error.message;\n      }\n\n      return response;\n    },\n  };\n  node = {\n    _api: this as Api,\n\n    async Echo(params: Echo) {\n      return await this._api.Send(\"daemon\", \"DERO.Echo\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.Echo\",\n        params,\n      });\n    },\n    async Ping() {\n      return await this._api.Send(\"daemon\", \"DERO.Ping\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.Ping\",\n        params: undefined,\n      });\n    },\n    async GetInfo() {\n      return await this._api.Send(\"daemon\", \"DERO.GetInfo\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetInfo\",\n        params: undefined,\n      });\n    },\n    async GetBlock(params: DEROGetBlock) {\n      return await this._api.Send(\"daemon\", \"DERO.GetBlock\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlock\",\n        params,\n      });\n    },\n    async GetBlockHeaderByTopoHeight(params: DEROGetBlockHeaderByTopoHeight) {\n      return await this._api.Send(\"daemon\", \"DERO.GetBlockHeaderByTopoHeight\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlockHeaderByTopoHeight\",\n        params,\n      });\n    },\n    async GetBlockHeaderByHash(params: DEROGetBlockHeaderByHash) {\n      return await this._api.Send(\"daemon\", \"DERO.GetBlockHeaderByHash\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlockHeaderByHash\",\n        params,\n      });\n    },\n    async GetTxPool() {\n      return await this._api.Send(\"daemon\", \"DERO.GetTxPool\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetTxPool\",\n        params: undefined,\n      });\n    },\n    async GetRandomAddress(params: DEROGetRandomAddress = {}) {\n      return await this._api.Send(\"daemon\", \"DERO.GetRandomAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetRandomAddress\",\n        params,\n      });\n    },\n    async GetTransaction(params: DEROGetTransaction) {\n      return await this._api.Send(\"daemon\", \"DERO.GetTransaction\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetTransaction\",\n        params,\n      });\n    },\n    /*async SendRawTransaction(params: DEROSendRawTransaction) {\n      return await this._api.sendSync(\n        \"daemon\",\n        \"DERO.SendRawTransaction\",\n        {\n          jsonrpc: \"2.0\",\n          method: \"DERO.SendRawTransaction\",\n          params,\n        }\n      );\n    },*/\n    async GetHeight() {\n      return await this._api.Send(\"daemon\", \"DERO.GetHeight\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetHeight\",\n        params: undefined,\n      });\n    },\n    async GetBlockCount() {\n      return await this._api.Send(\"daemon\", \"DERO.GetBlockCount\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlockCount\",\n        params: undefined,\n      });\n    },\n    async GetLastBlockHeader() {\n      return await this._api.Send(\"daemon\", \"DERO.GetLastBlockHeader\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetLastBlockHeader\",\n        params: undefined,\n      });\n    },\n    async GetBlockTemplate(params: DEROGetBlockTemplate) {\n      return await this._api.Send(\"daemon\", \"DERO.GetBlockTemplate\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetBlockTemplate\",\n        params,\n      });\n    },\n    async GetEncryptedBalance(params: DEROGetEncryptedBalance) {\n      return await this._api.Send(\"daemon\", \"DERO.GetEncryptedBalance\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetEncryptedBalance\",\n        params,\n      });\n    },\n    async GetSC(params: DEROGetSC, waitAfterNewBlock?: true) {\n      if (waitAfterNewBlock) {\n        debug(\"waiting for new block\");\n        this._api.subscribe({ event: \"new_topoheight\" });\n        await this._api.waitFor(\"new_topoheight\");\n      }\n      return await this._api.Send(\"daemon\", \"DERO.GetSC\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetSC\",\n        params,\n      });\n    },\n    async GetGasEstimate(params: DEROGetGasEstimate) {\n      // use gasEstimateSCArgs() to simplify usage\n      return await this._api.Send(\"daemon\", \"DERO.GetGasEstimate\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.GetGasEstimate\",\n        params,\n      });\n    },\n    async NameToAddress(params: DERONameToAddress) {\n      return await this._api.Send(\"daemon\", \"DERO.NameToAddress\", {\n        jsonrpc: \"2.0\",\n        method: \"DERO.NameToAddress\",\n        params,\n      });\n    },\n  };\n}\n\nfunction checkAppInfo(appInfo: AppInfo) {\n  if (appInfo.name !== undefined && appInfo.name.length == 0) {\n    throw \"invalid app name\";\n  }\n  if (appInfo.description !== undefined && appInfo.description.length == 0) {\n    throw \"invalid app description\";\n  }\n  if (appInfo.id !== undefined && appInfo.id.length != 64) {\n    throw \"invalid app id\";\n  }\n}\n","import {\n  ErrorResponse,\n  Response,\n  Result,\n  ResultResponse,\n} from \"./types/response\";\nimport { Entity } from \"./types/types\";\nimport { Method } from \"./types/request\";\nimport \"crypto\";\n\n/*\nasync function hash(message: string) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  const hash = await crypto.subtle.digest(\"SHA-256\", data);\n  return buf2hex(hash);\n}*/\n\nfunction pseudoHash(message: string, length: number = 64) {\n  message = new Array(64 - message.length)\n    .fill(0)\n    .map((_) => message)\n    .join(\"\");\n  console.assert(message.length > 1, \"message length must be > 1\");\n  return [...message]\n    .map((char, i) =>\n      Math.floor(char.charCodeAt(0) * ((7 + i) / (1 + (i % 7)))).toString(16)\n    )\n    .join(\"\")\n    .slice(0, 64);\n}\n\n/*\nfunction buf2hex(buffer: ArrayBuffer) {\n  return [...new Uint8Array(buffer)]\n    .map((x) => x.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n}*/\n\nexport function generateAppId(appName: string): string {\n  return pseudoHash(appName);\n}\n\nexport async function sleep(timems: number) {\n  await new Promise((r) => setTimeout(r, timems));\n}\n\nexport function to<\n  E extends Entity,\n  M extends Method<E>,\n  R extends Result = Result\n>(\n  response: Response<E, M, R>\n): [ErrorResponse | undefined, ResultResponse<E, M> | undefined] {\n  return [\n    \"error\" in response ? (response.error as ErrorResponse) : undefined,\n    \"result\" in response\n      ? (response.result as ResultResponse<E, M>)\n      : undefined,\n  ];\n}\n","import {\n  Address,\n  DVMString,\n  Entity,\n  EventType,\n  Hash,\n  SCCode,\n  Uint64,\n} from \"./types\";\n\nexport type JSONRPCRequest = {\n  method: \"POST\";\n  headers: {\n    \"Content-Type\": \"application/json\";\n  };\n  body: JSONRPCRequestBody<Entity, Method<Entity>>;\n};\n\nexport type JSONRPCRequestBody<E extends Entity, M extends Method<E>> = {\n  jsonrpc: \"2.0\";\n  id: string | number;\n  method: M;\n  params: Params<E, M>;\n};\n\nexport type Method<E extends Entity> = E extends \"daemon\"\n  ?\n      | \"DERO.Echo\"\n      | \"DERO.Ping\"\n      | \"DERO.GetInfo\"\n      | \"DERO.GetBlock\"\n      | \"DERO.GetBlockHeaderByTopoHeight\"\n      | \"DERO.GetBlockHeaderByHash\"\n      | \"DERO.GetTxPool\"\n      | \"DERO.GetRandomAddress\"\n      | \"DERO.GetTransaction\"\n      | \"DERO.SendRawTransaction\"\n      | \"DERO.GetHeight\"\n      | \"DERO.GetBlockCount\"\n      | \"DERO.GetLastBlockHeader\"\n      | \"DERO.GetBlockTemplate\"\n      | \"DERO.GetEncryptedBalance\"\n      | \"DERO.GetSC\"\n      | \"DERO.GetGasEstimate\"\n      | \"DERO.NameToAddress\"\n  :\n      | \"Echo\"\n      | \"GetAddress\"\n      | \"GetBalance\"\n      | \"GetHeight\"\n      | \"GetTransferbyTXID\"\n      | \"GetTransfers\"\n      | \"GetTrackedAssets\"\n      | \"MakeIntegratedAddress\"\n      | \"SplitIntegratedAddress\"\n      | \"QueryKey\"\n      | \"transfer\"\n      | \"scinvoke\"\n      | \"Subscribe\";\n\nexport type Params<\n  E extends Entity,\n  M extends Method<E>\n> = M extends \"DERO.Echo\"\n  ? Echo\n  : M extends \"DERO.Ping\"\n  ? undefined\n  : M extends \"DERO.GetInfo\"\n  ? undefined\n  : M extends \"DERO.GetBlock\"\n  ? DEROGetBlock\n  : M extends \"DERO.GetBlockHeaderByTopoHeight\"\n  ? DEROGetBlockHeaderByTopoHeight\n  : M extends \"DERO.GetBlockHeaderByHash\"\n  ? DEROGetBlockHeaderByHash\n  : M extends \"DERO.GetTxPool\"\n  ? undefined\n  : M extends \"DERO.GetRandomAddress\"\n  ? DEROGetRandomAddress\n  : M extends \"DERO.GetTransaction\"\n  ? DEROGetTransaction\n  : M extends \"DERO.SendRawTransaction\"\n  ? DEROSendRawTransaction\n  : M extends \"DERO.GetHeight\"\n  ? undefined\n  : M extends \"DERO.GetBlockCount\"\n  ? undefined\n  : M extends \"DERO.GetLastBlockHeader\"\n  ? undefined\n  : M extends \"DERO.GetBlockTemplate\"\n  ? DEROGetBlockTemplate\n  : M extends \"DERO.GetEncryptedBalance\"\n  ? DEROGetEncryptedBalance\n  : M extends \"DERO.GetSC\"\n  ? DEROGetSC\n  : M extends \"DERO.GetGasEstimate\"\n  ? DEROGetGasEstimate\n  : M extends \"DERO.NameToAddress\"\n  ? DERONameToAddress\n  : M extends \"GetAddress\"\n  ? undefined\n  : M extends \"GetBalance\"\n  ? GetBalance\n  : M extends \"GetHeight\"\n  ? undefined\n  : M extends \"GetTrackedAssets\"\n  ? GetTrackedAssets\n  : M extends \"GetTransferbyTXID\"\n  ? GetTransferbyTXID\n  : M extends \"GetTransfers\"\n  ? GetTransfers\n  : M extends \"MakeIntegratedAddress\"\n  ? MakeIntegratedAddress\n  : M extends \"SplitIntegratedAddress\"\n  ? SplitIntegratedAddress\n  : M extends \"QueryKey\"\n  ? QueryKey\n  : M extends \"transfer\"\n  ? Transfer\n  : M extends \"scinvoke\"\n  ? SCInvoke\n  : M extends \"Subscribe\"\n  ? { event: EventType }\n  : Echo;\n\nexport type Echo = DVMString[];\n\nexport type WalletTransfer = {\n  amount?: Uint64;\n  burn?: Uint64;\n  destination?: string;\n  scid?: Hash;\n  payload_rpc?: Arguments;\n};\n\ntype ArgumentType = Uint64 | DVMString | Hash;\ntype Argument<AT extends ArgumentType> = {\n  name: DVMString;\n  datatype: AT extends Uint64\n    ? \"U\"\n    : AT extends Hash | DVMString\n    ? \"H\" | \"S\"\n    : unknown;\n  value: AT;\n};\n\ntype Arguments = Argument<ArgumentType>[];\n\nexport type DEROGetBlock = {\n  hash?: Hash;\n  height?: Uint64;\n};\n\nexport type DEROGetBlockHeaderByTopoHeight = {\n  topoheight: Uint64;\n};\n\nexport type DEROGetBlockHeaderByHash = {\n  hash: Hash;\n};\n\nexport type DEROGetRandomAddress = {\n  scid?: Hash;\n};\n\nexport type DEROGetTransaction = {\n  txs_hashes: Hash[];\n  decode_as_json?: Uint64;\n};\n\nexport type DEROSendRawTransaction = {\n  tx_as_hex: DVMString;\n};\n\nexport type DEROGetBlockTemplate = {\n  wallet_address: DVMString;\n  block?: boolean;\n  miner?: DVMString;\n};\n\nexport type DEROGetEncryptedBalance = {\n  address: DVMString;\n  topoheight: Uint64;\n  scid?: Hash;\n  treehash?: Hash;\n};\n\nexport type DEROGetSC = {\n  scid: Hash;\n  code?: boolean;\n  variables?: boolean;\n  topoheight?: Uint64;\n  keysuint64?: Uint64[];\n  keysstring?: DVMString[];\n  keysbytes?: Int8Array[];\n};\n\n// TODO rename transferSCArgs, used in both transfer and gasEstimate\nexport function gasEstimateSCArgs(\n  scid: Hash,\n  entrypoint: string,\n  args: { name: string; value: DVMString | Uint64 }[]\n): Argument<ArgumentType>[] {\n  return [\n    {\n      name: \"SC_ACTION\",\n      datatype: \"U\",\n      value: 0,\n    },\n    {\n      name: \"SC_ID\",\n      datatype: \"H\",\n      value: scid,\n    },\n    ...scinvokeSCArgs(entrypoint, args),\n  ];\n}\n\nexport function scinvokeSCArgs(\n  entrypoint: string,\n  args: { name: string; value: DVMString | Uint64 }[]\n): Argument<ArgumentType>[] {\n  const formattedArgs: Argument<ArgumentType>[] = args.map(\n    ({ name, value }) => ({\n      name,\n      datatype: typeof value == \"number\" ? \"U\" : \"S\", //? bigint?\n      value,\n    })\n  );\n  return [\n    {\n      name: \"entrypoint\",\n      datatype: \"S\",\n      value: entrypoint,\n    },\n    ...formattedArgs,\n  ];\n}\n\nexport type DEROGetGasEstimate = {\n  transfers?: WalletTransfer[];\n  sc?: SCCode;\n  sc_rpc?: Argument<ArgumentType>[];\n  signer?: Address;\n};\n\nexport type DERONameToAddress = {\n  name: DVMString;\n  topoheight: Uint64;\n};\n\nexport type GetBalance = {\n  scid?: Hash;\n};\n\nexport type GetTrackedAssets = {\n  only_positive_balances: boolean;\n  skip_balance_check: boolean;\n};\n\nexport type GetTransferbyTXID = {\n  hash?: Hash;\n  txid?: Hash;\n};\n\nexport type GetTransfers = {\n  scid?: Hash;\n  coinbase?: boolean;\n  in?: boolean;\n  out?: boolean;\n  min_height?: Uint64;\n  max_height?: Uint64;\n  sender?: DVMString;\n  receiver?: DVMString;\n  dstport?: Uint64;\n  srcport?: Uint64;\n};\n\nexport type MakeIntegratedAddress = {\n  address?: DVMString;\n  payload_rpc?: Argument<ArgumentType>;\n};\n\nexport type SplitIntegratedAddress = {\n  integrated_address: DVMString;\n};\n\nexport type QueryKey = { key_type: \"mnemonic\" };\n\nexport type Transfer = {\n  transfers?: WalletTransfer[];\n  sc?: SCCode;\n  sc_rpc?: Arguments;\n  ringsize?: Uint64;\n  scid?: Hash;\n  fees?: Uint64;\n  signer?: Address;\n};\n\nexport type SCInvoke = {\n  scid: Hash;\n  sc_rpc: Arguments;\n\n  sc_dero_deposit?: Uint64;\n  sc_token_deposit?: Uint64;\n  ringsize?: Uint64;\n};\n"],"mappings":"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","names":["ConnectionState","error"]}
\ No newline at end of file
